{
  "version": 3,
  "sources": ["../../@deck.gl/aggregation-layers/src/common/aggregator/cpu-aggregator/sort-bins.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/cpu-aggregator/aggregate.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/cpu-aggregator/vertex-accessor.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/cpu-aggregator/cpu-aggregator.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/gpu-aggregator/utils.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/gpu-aggregator/bin-sorter-uniforms.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/gpu-aggregator/webgl-bin-sorter.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/gpu-aggregator/webgl-aggregation-transform.ts", "../../@deck.gl/aggregation-layers/src/common/aggregator/gpu-aggregator/webgl-aggregator.ts", "../../@deck.gl/aggregation-layers/src/common/aggregation-layer.ts", "../../@deck.gl/aggregation-layers/src/common/utils/color-utils.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer-vertex.glsl.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer-fragment.glsl.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer-uniforms.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-cell-layer.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/bin-options-uniforms.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer.ts", "../../@deck.gl/aggregation-layers/src/common/utils/scale-utils.ts", "../../@deck.gl/aggregation-layers/src/common/utils/bounds-utils.ts", "../../@deck.gl/aggregation-layers/src/hexagon-layer/hexbin.ts", "../../@deck.gl/aggregation-layers/src/hexagon-layer/hexagon-cell-layer-vertex.glsl.ts", "../../@deck.gl/aggregation-layers/src/hexagon-layer/hexagon-layer-uniforms.ts", "../../@deck.gl/aggregation-layers/src/hexagon-layer/hexagon-cell-layer.ts", "../../@deck.gl/aggregation-layers/src/hexagon-layer/bin-options-uniforms.ts", "../../@deck.gl/aggregation-layers/src/hexagon-layer/hexagon-layer.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/marching-squares-codes.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/marching-squares.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/contour-utils.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/value-reader.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/bin-options-uniforms.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/contour-layer.ts", "../../@deck.gl/aggregation-layers/src/grid-layer/grid-cell-layer-vertex.glsl.ts", "../../@deck.gl/aggregation-layers/src/grid-layer/grid-layer-uniforms.ts", "../../@deck.gl/aggregation-layers/src/grid-layer/grid-cell-layer.ts", "../../@deck.gl/aggregation-layers/src/grid-layer/bin-options-uniforms.ts", "../../@deck.gl/aggregation-layers/src/grid-layer/grid-layer.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/heatmap-layer-utils.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/triangle-layer-vertex.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/triangle-layer-fragment.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/triangle-layer-uniforms.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/triangle-layer.ts", "../../@deck.gl/aggregation-layers/src/common/utils/prop-utils.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/aggregation-layer.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/weights-vs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/weights-fs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/max-vs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/max-fs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/heatmap-layer-uniforms.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/heatmap-layer.ts"],
  "sourcesContent": ["// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Bin} from './cpu-aggregator';\r\n\r\n/** Group data points into bins */\r\nexport function sortBins({\r\n  pointCount,\r\n  getBinId\r\n}: {\r\n  pointCount: number;\r\n  getBinId: (index: number) => number[] | null;\r\n}): Bin[] {\r\n  const binsById: Map<string, Bin> = new Map();\r\n\r\n  for (let i = 0; i < pointCount; i++) {\r\n    const id = getBinId(i);\r\n    if (id === null) {\r\n      continue;\r\n    }\r\n    let bin = binsById.get(String(id));\r\n    if (bin) {\r\n      bin.points.push(i);\r\n    } else {\r\n      bin = {\r\n        id,\r\n        index: binsById.size,\r\n        points: [i]\r\n      };\r\n      binsById.set(String(id), bin);\r\n    }\r\n  }\r\n  return Array.from(binsById.values());\r\n}\r\n\r\n/** Pack bin ids into a typed array */\r\nexport function packBinIds({\r\n  bins,\r\n  dimensions,\r\n  target\r\n}: {\r\n  bins: Bin[];\r\n  /** Size of bin IDs */\r\n  dimensions: number;\r\n  /** Array to write output into */\r\n  target?: Float32Array | null;\r\n}): Float32Array {\r\n  const targetLength = bins.length * dimensions;\r\n  if (!target || target.length < targetLength) {\r\n    target = new Float32Array(targetLength);\r\n  }\r\n\r\n  for (let i = 0; i < bins.length; i++) {\r\n    const {id} = bins[i];\r\n    if (Array.isArray(id)) {\r\n      target.set(id, i * dimensions);\r\n    } else {\r\n      target[i] = id;\r\n    }\r\n  }\r\n  return target;\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Bin} from './cpu-aggregator';\r\nimport type {AggregationOperation} from '../aggregator';\r\n\r\n/** A reducer function that takes a list of data points and outputs one measurement */\r\nexport type AggregationFunc = (\r\n  /** Indices of the points */\r\n  pointIndices: number[],\r\n  /** Accessor to the value for each point */\r\n  getValue: (index: number) => number\r\n) => number;\r\n\r\nconst count: AggregationFunc = pointIndices => {\r\n  return pointIndices.length;\r\n};\r\n\r\nconst sum: AggregationFunc = (pointIndices, getValue) => {\r\n  let result = 0;\r\n  for (const i of pointIndices) {\r\n    result += getValue(i);\r\n  }\r\n  return result;\r\n};\r\n\r\nconst mean: AggregationFunc = (pointIndices, getValue) => {\r\n  if (pointIndices.length === 0) {\r\n    return NaN;\r\n  }\r\n  return sum(pointIndices, getValue) / pointIndices.length;\r\n};\r\n\r\nconst min: AggregationFunc = (pointIndices, getValue) => {\r\n  let result = Infinity;\r\n  for (const i of pointIndices) {\r\n    const value = getValue(i);\r\n    if (value < result) {\r\n      result = value;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nconst max: AggregationFunc = (pointIndices, getValue) => {\r\n  let result = -Infinity;\r\n  for (const i of pointIndices) {\r\n    const value = getValue(i);\r\n    if (value > result) {\r\n      result = value;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexport const BUILT_IN_OPERATIONS: Record<AggregationOperation, AggregationFunc> = {\r\n  COUNT: count,\r\n  SUM: sum,\r\n  MEAN: mean,\r\n  MIN: min,\r\n  MAX: max\r\n} as const;\r\n\r\n/**\r\n * Performs the aggregation step. See interface Aggregator comments.\r\n * @returns Floa32Array of aggregated values, one for each bin, and the [min,max] of the values\r\n */\r\nexport function aggregate({\r\n  bins,\r\n  getValue,\r\n  operation,\r\n  target\r\n}: {\r\n  /** Data points sorted by bins */\r\n  bins: Bin[];\r\n  /** Given the index of a data point, returns its value */\r\n  getValue: (index: number) => number;\r\n  /** Method used to reduce a list of values to one number */\r\n  operation: AggregationFunc;\r\n  /** Array to write the output into */\r\n  target?: Float32Array | null;\r\n}): {\r\n  value: Float32Array;\r\n  domain: [min: number, max: number];\r\n} {\r\n  if (!target || target.length < bins.length) {\r\n    target = new Float32Array(bins.length);\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-shadow\r\n  let min = Infinity;\r\n  // eslint-disable-next-line @typescript-eslint/no-shadow\r\n  let max = -Infinity;\r\n\r\n  for (let j = 0; j < bins.length; j++) {\r\n    const {points} = bins[j];\r\n    target[j] = operation(points, getValue);\r\n    if (target[j] < min) min = target[j];\r\n    if (target[j] > max) max = target[j];\r\n  }\r\n\r\n  return {value: target, domain: [min, max]};\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Attribute} from '@deck.gl/core';\r\nimport type {TypedArray} from '@luma.gl/core';\r\n\r\n/** This is designed to mirror a vertex shader function\r\n * For each vertex, calculates a value from attribtes, vertex index and options (uniforms)\r\n */\r\nexport type VertexAccessor<ValueT, OptionsT = undefined> = {\r\n  /** Attribute ids that provide input to getValue, used to index into the attributes map.\r\n   * For example `['position', 'size']`\r\n   */\r\n  sources?: string[];\r\n  /** Called for each data point to retrieve a value during update. */\r\n  getValue: (\r\n    /** Attributes at the vertex index */\r\n    data: any,\r\n    /** Vertex index */\r\n    index: number,\r\n    /** Shared options across all vertices */\r\n    options: OptionsT\r\n  ) => ValueT;\r\n};\r\n\r\n/** Evaluate a VertexAccessor with a set of attributes */\r\nexport function evaluateVertexAccessor<ValueT, OptionsT>(\r\n  accessor: VertexAccessor<ValueT, OptionsT>,\r\n  attributes: Record<string, Attribute>,\r\n  options: OptionsT\r\n): (vertexIndex: number) => ValueT {\r\n  const vertexReaders: {[id: string]: (i: number) => number | number[]} = {};\r\n  for (const id of accessor.sources || []) {\r\n    const attribute = attributes[id];\r\n    if (attribute) {\r\n      vertexReaders[id] = getVertexReader(attribute);\r\n    } else {\r\n      throw new Error(`Cannot find attribute ${id}`);\r\n    }\r\n  }\r\n  const data: {[id: string]: number | number[]} = {};\r\n\r\n  return (vertexIndex: number) => {\r\n    for (const id in vertexReaders) {\r\n      data[id] = vertexReaders[id](vertexIndex);\r\n    }\r\n    return accessor.getValue(data, vertexIndex, options);\r\n  };\r\n}\r\n\r\n/** Read value out of a deck.gl Attribute by vertex */\r\nfunction getVertexReader(attribute: Attribute): (vertexIndex: number) => number | number[] {\r\n  const value = attribute.value as TypedArray;\r\n  const {offset = 0, stride, size} = attribute.getAccessor();\r\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\r\n  const elementOffset = offset / bytesPerElement;\r\n  const elementStride = stride ? stride / bytesPerElement : size;\r\n\r\n  if (size === 1) {\r\n    // Size 1, returns (i: number) => number\r\n    if (attribute.isConstant) {\r\n      return () => value[0];\r\n    }\r\n    return (vertexIndex: number) => {\r\n      const i = elementOffset + elementStride * vertexIndex;\r\n      return value[i];\r\n    };\r\n  }\r\n\r\n  // Size >1, returns (i: number) => number[]\r\n  let result: number[];\r\n  if (attribute.isConstant) {\r\n    result = Array.from(value);\r\n    return () => result;\r\n  }\r\n\r\n  result = new Array(size);\r\n  return (vertexIndex: number) => {\r\n    const i = elementOffset + elementStride * vertexIndex;\r\n    for (let j = 0; j < size; j++) {\r\n      result[j] = value[i + j];\r\n    }\r\n    return result;\r\n  };\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Aggregator, AggregationProps, AggregatedBin} from '../aggregator';\r\nimport {_deepEqual as deepEqual, BinaryAttribute} from '@deck.gl/core';\r\nimport {sortBins, packBinIds} from './sort-bins';\r\nimport {aggregate, AggregationFunc, BUILT_IN_OPERATIONS} from './aggregate';\r\nimport {VertexAccessor, evaluateVertexAccessor} from './vertex-accessor';\r\n\r\n/** Options used to construct a new CPUAggregator */\r\nexport type CPUAggregatorProps = {\r\n  /** Size of bin IDs */\r\n  dimensions: number;\r\n  /** Accessor to map each data point to a bin ID.\r\n   * Bin ID should be an array with [dimensions] elements; or null if the data point should be skipped\r\n   */\r\n  getBin: VertexAccessor<number[] | null, any>;\r\n  /** Accessor to map each data point to a weight value, defined per channel */\r\n  getValue: VertexAccessor<number>[];\r\n} & Partial<CPUAggregationProps>;\r\n\r\n/** Props used to run CPU aggregation, can be changed at any time */\r\ntype CPUAggregationProps = AggregationProps & {\r\n  /** Custom callback to aggregate points, overrides the built-in operations */\r\n  customOperations: (AggregationFunc | null | undefined)[];\r\n};\r\n\r\nexport type Bin = {\r\n  id: number[];\r\n  index: number;\r\n  /** list of data point indices */\r\n  points: number[];\r\n};\r\n\r\n/** An Aggregator implementation that calculates aggregation on the CPU */\r\nexport class CPUAggregator implements Aggregator {\r\n  readonly dimensions: number;\r\n  readonly channelCount: number;\r\n\r\n  props: CPUAggregatorProps & CPUAggregationProps;\r\n\r\n  /** Dirty flag\r\n   * If true, redo sorting\r\n   * If array, redo aggregation on the specified channel\r\n   */\r\n  protected needsUpdate: boolean[] | boolean;\r\n\r\n  protected bins: Bin[] = [];\r\n  protected binIds: (BinaryAttribute & {value: Float32Array}) | null = null;\r\n  protected results: (BinaryAttribute & {\r\n    value: Float32Array;\r\n    domain: [min: number, max: number];\r\n  })[] = [];\r\n\r\n  constructor(props: CPUAggregatorProps) {\r\n    this.dimensions = props.dimensions;\r\n    this.channelCount = props.getValue.length;\r\n    this.props = {\r\n      ...props,\r\n      binOptions: {},\r\n      pointCount: 0,\r\n      operations: [],\r\n      customOperations: [],\r\n      attributes: {}\r\n    };\r\n    this.needsUpdate = true;\r\n    this.setProps(props);\r\n  }\r\n\r\n  destroy() {}\r\n\r\n  get binCount() {\r\n    return this.bins.length;\r\n  }\r\n\r\n  /** Update aggregation props */\r\n  // eslint-disable-next-line complexity\r\n  setProps(props: Partial<CPUAggregationProps>) {\r\n    const oldProps = this.props;\r\n\r\n    if (props.binOptions) {\r\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\r\n        this.setNeedsUpdate();\r\n      }\r\n    }\r\n    if (props.operations) {\r\n      for (let channel = 0; channel < this.channelCount; channel++) {\r\n        if (props.operations[channel] !== oldProps.operations[channel]) {\r\n          this.setNeedsUpdate(channel);\r\n        }\r\n      }\r\n    }\r\n    if (props.customOperations) {\r\n      for (let channel = 0; channel < this.channelCount; channel++) {\r\n        if (\r\n          Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])\r\n        ) {\r\n          this.setNeedsUpdate(channel);\r\n        }\r\n      }\r\n    }\r\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\r\n      this.setNeedsUpdate();\r\n    }\r\n    if (props.attributes) {\r\n      props.attributes = {...oldProps.attributes, ...props.attributes};\r\n    }\r\n    Object.assign(this.props, props);\r\n  }\r\n\r\n  /** Flags a channel to need update\r\n   * This is called internally by setProps() if certain props change\r\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\r\n   * the underlying buffers could have been updated and require rerunning the aggregation\r\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\r\n   */\r\n  setNeedsUpdate(channel?: number): void {\r\n    if (channel === undefined) {\r\n      this.needsUpdate = true;\r\n    } else if (this.needsUpdate !== true) {\r\n      this.needsUpdate = this.needsUpdate || [];\r\n      this.needsUpdate[channel] = true;\r\n    }\r\n  }\r\n\r\n  /** Run aggregation */\r\n  update() {\r\n    if (this.needsUpdate === true) {\r\n      this.bins = sortBins({\r\n        pointCount: this.props.pointCount,\r\n        getBinId: evaluateVertexAccessor(\r\n          this.props.getBin,\r\n          this.props.attributes,\r\n          this.props.binOptions\r\n        )\r\n      });\r\n      const value = packBinIds({\r\n        bins: this.bins,\r\n        dimensions: this.dimensions,\r\n        // Reuse allocated typed array\r\n        target: this.binIds?.value\r\n      });\r\n      this.binIds = {value, type: 'float32', size: this.dimensions};\r\n    }\r\n    for (let channel = 0; channel < this.channelCount; channel++) {\r\n      if (this.needsUpdate === true || this.needsUpdate[channel]) {\r\n        const operation =\r\n          this.props.customOperations[channel] ||\r\n          BUILT_IN_OPERATIONS[this.props.operations[channel]];\r\n        const {value, domain} = aggregate({\r\n          bins: this.bins,\r\n          getValue: evaluateVertexAccessor(\r\n            this.props.getValue[channel],\r\n            this.props.attributes,\r\n            undefined\r\n          ),\r\n          operation,\r\n          // Reuse allocated typed array\r\n          target: this.results[channel]?.value\r\n        });\r\n        this.results[channel] = {value, domain, type: 'float32', size: 1};\r\n        this.props.onUpdate?.({channel});\r\n      }\r\n    }\r\n    this.needsUpdate = false;\r\n  }\r\n\r\n  preDraw() {}\r\n\r\n  /** Returns an accessor to the bins. */\r\n  getBins(): BinaryAttribute | null {\r\n    return this.binIds;\r\n  }\r\n\r\n  /** Returns an accessor to the output for a given channel. */\r\n  getResult(channel: number): BinaryAttribute | null {\r\n    return this.results[channel];\r\n  }\r\n\r\n  /** Returns the [min, max] of aggregated values for a given channel. */\r\n  getResultDomain(channel: number): [min: number, max: number] {\r\n    return this.results[channel]?.domain ?? [Infinity, -Infinity];\r\n  }\r\n\r\n  /** Returns the information for a given bin. */\r\n  getBin(index: number): AggregatedBin | null {\r\n    const bin = this.bins[index];\r\n    if (!bin) {\r\n      return null;\r\n    }\r\n    const value = new Array(this.channelCount);\r\n    for (let i = 0; i < value.length; i++) {\r\n      const result = this.results[i];\r\n      value[i] = result?.value[index];\r\n    }\r\n    return {\r\n      id: bin.id,\r\n      value,\r\n      count: bin.points.length,\r\n      pointIndices: bin.points\r\n    };\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Device, Framebuffer} from '@luma.gl/core';\r\n\r\n/**\r\n * Create a float texture to store aggregation result\r\n */\r\nexport function createRenderTarget(device: Device, width: number, height: number): Framebuffer {\r\n  return device.createFramebuffer({\r\n    width,\r\n    height,\r\n    colorAttachments: [\r\n      device.createTexture({\r\n        width,\r\n        height,\r\n        format: 'rgba32float',\r\n        mipmaps: false,\r\n        sampler: {\r\n          minFilter: 'nearest',\r\n          magFilter: 'nearest'\r\n        }\r\n      })\r\n    ]\r\n  });\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {NumberArray2, NumberArray4} from '@math.gl/core';\r\nimport {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform binSorterUniforms {\r\n  ivec4 binIdRange;\r\n  ivec2 targetSize;\r\n} binSorter;\r\n`;\r\n\r\nexport type BinSorterProps = {\r\n  binIdRange: NumberArray4;\r\n  targetSize: NumberArray2;\r\n};\r\n\r\nexport const binSorterUniforms = {\r\n  name: 'binSorter',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    binIdRange: 'vec4<i32>',\r\n    targetSize: 'vec2<i32>'\r\n  }\r\n} as const satisfies ShaderModule<BinSorterProps>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Model, ModelProps} from '@luma.gl/engine';\r\nimport {createRenderTarget} from './utils';\r\n\r\nimport type {Device, Framebuffer, Texture} from '@luma.gl/core';\r\nimport type {WebGLAggregatorProps} from './webgl-aggregator';\r\nimport type {AggregationOperation} from '../aggregator';\r\nimport {BinSorterProps, binSorterUniforms} from './bin-sorter-uniforms';\r\n\r\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPU color mask RED, GREEN, BLUE, ALPHA\r\nconst MAX_FLOAT32 = 3e38;\r\nconst EMPTY_MASKS = {SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0};\r\n\r\nexport const TEXTURE_WIDTH = 1024;\r\n\r\n/**\r\n * This class manages the resources for performing the first step of aggregation\r\n * Sort a list of data points into a number of bins\r\n */\r\nexport class WebGLBinSorter {\r\n  device: Device;\r\n  model: Model;\r\n\r\n  /**\r\n   * A packed texture in which each pixel represents a bin.\r\n   * The index of the pixel in the memory layout is the bin index.\r\n   * Alpha value is the count of data points that fall into this bin\r\n   * R,G,B values are the aggregated values of each channel:\r\n   *   - Sum of all data points if operation is 'SUM', or 'MEAN'\r\n   *   - Min of all data points if operation is 'MIN'\r\n   *   - Max of all data points if operation is 'MAX'\r\n   */\r\n  private binsFBO: Framebuffer | null = null;\r\n\r\n  constructor(device: Device, props: WebGLAggregatorProps) {\r\n    this.device = device;\r\n    this.model = createModel(device, props);\r\n  }\r\n\r\n  get texture(): Texture | null {\r\n    return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;\r\n  }\r\n\r\n  destroy() {\r\n    this.model.destroy();\r\n    this.binsFBO?.colorAttachments[0].texture.destroy();\r\n    this.binsFBO?.destroy();\r\n  }\r\n\r\n  getBinValues(index: number): Float32Array | null {\r\n    if (!this.binsFBO) {\r\n      return null;\r\n    }\r\n    const x = index % TEXTURE_WIDTH;\r\n    const y = Math.floor(index / TEXTURE_WIDTH);\r\n    const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {\r\n      sourceX: x,\r\n      sourceY: y,\r\n      sourceWidth: 1,\r\n      sourceHeight: 1\r\n    }).buffer;\r\n    return new Float32Array(buffer);\r\n  }\r\n\r\n  setDimensions(binCount: number, binIdRange: [number, number][]) {\r\n    const width = TEXTURE_WIDTH;\r\n    const height = Math.ceil(binCount / width);\r\n\r\n    // Only destroy existing texture if it is not large enough\r\n    if (!this.binsFBO) {\r\n      this.binsFBO = createRenderTarget(this.device, width, height);\r\n    } else if (this.binsFBO.height < height) {\r\n      this.binsFBO.resize({width, height});\r\n    }\r\n\r\n    const binSorterProps: BinSorterProps = {\r\n      binIdRange: [\r\n        binIdRange[0][0],\r\n        binIdRange[0][1],\r\n        binIdRange[1]?.[0] || 0,\r\n        binIdRange[1]?.[1] || 0\r\n      ],\r\n      targetSize: [this.binsFBO.width, this.binsFBO.height]\r\n    };\r\n    this.model.shaderInputs.setProps({binSorter: binSorterProps});\r\n  }\r\n\r\n  setModelProps(\r\n    props: Pick<ModelProps, 'vertexCount' | 'uniforms' | 'attributes' | 'constantAttributes'> & {\r\n      shaderModuleProps?: Record<string, any>;\r\n    }\r\n  ) {\r\n    const model = this.model;\r\n    if (props.attributes) {\r\n      model.setAttributes(props.attributes);\r\n    }\r\n    if (props.constantAttributes) {\r\n      model.setConstantAttributes(props.constantAttributes);\r\n    }\r\n    if (props.vertexCount !== undefined) {\r\n      model.setVertexCount(props.vertexCount);\r\n    }\r\n    if (props.shaderModuleProps) {\r\n      model.shaderInputs.setProps(props.shaderModuleProps);\r\n    }\r\n  }\r\n\r\n  /** Update aggregation */\r\n  update(\r\n    /** The aggregation operation for each channel. Use null to skip update. */\r\n    operations: (AggregationOperation | null)[]\r\n  ) {\r\n    if (!this.binsFBO) {\r\n      return;\r\n    }\r\n    const masks = getMaskByOperation(operations);\r\n    this._updateBins('SUM', masks.SUM + masks.MEAN);\r\n    this._updateBins('MIN', masks.MIN);\r\n    this._updateBins('MAX', masks.MAX);\r\n  }\r\n\r\n  /** Recalculate aggregation on the given channels using the given operation */\r\n  private _updateBins(\r\n    operation: AggregationOperation,\r\n    /** GPU bit mask of one or more channels that should be updated */\r\n    colorMask: number\r\n  ) {\r\n    if (colorMask === 0) {\r\n      return;\r\n    }\r\n    colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)\r\n\r\n    const model = this.model;\r\n    const target = this.binsFBO!;\r\n\r\n    const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;\r\n    const renderPass = this.device.beginRenderPass({\r\n      id: `gpu-aggregation-${operation}`,\r\n      framebuffer: target,\r\n      parameters: {\r\n        viewport: [0, 0, target.width, target.height],\r\n        colorMask\r\n      },\r\n      clearColor: [initialValue, initialValue, initialValue, 0],\r\n      clearDepth: false,\r\n      clearStencil: false\r\n    });\r\n    model.setParameters({\r\n      blend: true,\r\n      blendColorSrcFactor: 'one',\r\n      blendColorDstFactor: 'one',\r\n      blendAlphaSrcFactor: 'one',\r\n      blendAlphaDstFactor: 'one',\r\n      blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',\r\n      blendAlphaOperation: 'add'\r\n    });\r\n    model.draw(renderPass);\r\n    renderPass.end();\r\n  }\r\n}\r\n\r\n/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */\r\nfunction getMaskByOperation(\r\n  operations: (AggregationOperation | null)[]\r\n): Record<AggregationOperation, number> {\r\n  const result: Record<AggregationOperation, number> = {...EMPTY_MASKS};\r\n  for (let channel = 0; channel < operations.length; channel++) {\r\n    const op = operations[channel];\r\n    if (op) {\r\n      result[op] += COLOR_CHANNELS[channel];\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction createModel(device: Device, props: WebGLAggregatorProps): Model {\r\n  let userVs = props.vs;\r\n\r\n  if (props.dimensions === 2) {\r\n    // If user provides 2d bin IDs, convert them to 1d indices for data packing\r\n    userVs += /* glsl */ `\r\nvoid getBin(out int binId) {\r\n  ivec2 binId2;\r\n  getBin(binId2);\r\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\r\n    binId = -1;\r\n  } else {\r\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\r\n  }\r\n}\r\n`;\r\n  }\r\n\r\n  const vs = `\\\r\n#version 300 es\r\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\r\n\r\n${userVs}\r\n\r\nout vec3 v_Value;\r\n\r\nvoid main() {\r\n  int binIndex;\r\n  getBin(binIndex);\r\n  binIndex = binIndex - binSorter.binIdRange.x;\r\n  if (binIndex < 0) {\r\n    gl_Position = vec4(0.);\r\n    return;\r\n  }\r\n  int row = binIndex / binSorter.targetSize.x;\r\n  int col = binIndex - row * binSorter.targetSize.x;\r\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\r\n  gl_Position = vec4(position, 0.0, 1.0);\r\n  gl_PointSize = 1.0;\r\n\r\n#if NUM_CHANNELS == 3\r\n  getValue(v_Value);\r\n#elif NUM_CHANNELS == 2\r\n  getValue(v_Value.xy);\r\n#else\r\n  getValue(v_Value.x);\r\n#endif\r\n}\r\n`;\r\n  const fs = /* glsl */ `\\\r\n#version 300 es\r\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\r\n\r\nprecision highp float;\r\n\r\nin vec3 v_Value;\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  fragColor.xyz = v_Value;\r\n\r\n  #ifdef MODULE_GEOMETRY\r\n  geometry.uv = vec2(0.);\r\n  DECKGL_FILTER_COLOR(fragColor, geometry);\r\n  #endif\r\n\r\n  fragColor.w = 1.0;\r\n}\r\n`;\r\n  const model = new Model(device, {\r\n    bufferLayout: props.bufferLayout,\r\n    modules: [...(props.modules || []), binSorterUniforms],\r\n    defines: {...props.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: props.channelCount},\r\n    isInstanced: false,\r\n    vs,\r\n    fs,\r\n    topology: 'point-list',\r\n    disableWarnings: true\r\n  });\r\n  return model;\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {NumberArray3, NumberArray4} from '@math.gl/core';\r\nimport {ShaderModule} from '@luma.gl/shadertools';\r\nimport {Texture} from '@luma.gl/core';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform aggregatorTransformUniforms {\r\n  ivec4 binIdRange;\r\n  bvec3 isCount;\r\n  bvec3 isMean;\r\n  float naN;\r\n} aggregatorTransform;\r\n`;\r\n\r\nexport type AggregatorTransformProps = {\r\n  binIdRange: NumberArray4;\r\n  isCount: NumberArray3;\r\n  isMean: NumberArray3;\r\n  bins: Texture;\r\n};\r\n\r\nexport const aggregatorTransformUniforms = {\r\n  name: 'aggregatorTransform',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    binIdRange: 'vec4<i32>',\r\n    isCount: 'vec3<f32>',\r\n    isMean: 'vec3<f32>'\r\n  }\r\n} as const satisfies ShaderModule<AggregatorTransformProps>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {BufferTransform} from '@luma.gl/engine';\r\nimport {createRenderTarget} from './utils';\r\n\r\nimport type {Device, Framebuffer, Buffer, Texture} from '@luma.gl/core';\r\nimport type {WebGLAggregatorProps} from './webgl-aggregator';\r\nimport type {AggregationOperation} from '../aggregator';\r\n\r\nimport {TEXTURE_WIDTH} from './webgl-bin-sorter';\r\nimport {\r\n  AggregatorTransformProps,\r\n  aggregatorTransformUniforms\r\n} from './aggregation-transform-uniforms';\r\nimport {NumberArray3} from '@math.gl/core';\r\n\r\nconst MAX_FLOAT32 = 3e38;\r\n\r\nexport class WebGLAggregationTransform {\r\n  device: Device;\r\n  channelCount: number;\r\n\r\n  /** Packed from bin ids */\r\n  binBuffer: Buffer | null = null;\r\n  /** Packed values from each channel of each bin\r\n   * Stride is number of channels * 4 bytes (float32)\r\n   */\r\n  valueBuffer: Buffer | null = null;\r\n\r\n  private transform: BufferTransform;\r\n  /** Render target for calculating domain */\r\n  private domainFBO: Framebuffer;\r\n  /** Aggregated [min, max] for each channel */\r\n  private _domains: [min: number, max: number][] | null = null;\r\n\r\n  constructor(device: Device, props: WebGLAggregatorProps) {\r\n    this.device = device;\r\n    this.channelCount = props.channelCount;\r\n    this.transform = createTransform(device, props);\r\n    this.domainFBO = createRenderTarget(device, 2, 1);\r\n  }\r\n\r\n  destroy() {\r\n    this.transform.destroy();\r\n    this.binBuffer?.destroy();\r\n    this.valueBuffer?.destroy();\r\n    this.domainFBO.colorAttachments[0].texture.destroy();\r\n    this.domainFBO.destroy();\r\n  }\r\n\r\n  get domains(): [min: number, max: number][] {\r\n    if (!this._domains) {\r\n      // Domain model has run, but result has not been read to CPU\r\n      const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;\r\n      const domain = new Float32Array(buffer);\r\n      this._domains = [\r\n        [-domain[4], domain[0]],\r\n        [-domain[5], domain[1]],\r\n        [-domain[6], domain[2]]\r\n      ].slice(0, this.channelCount) as [number, number][];\r\n    }\r\n    return this._domains;\r\n  }\r\n\r\n  setDimensions(binCount: number, binIdRange: [number, number][]) {\r\n    const {model, transformFeedback} = this.transform;\r\n    model.setVertexCount(binCount);\r\n    const aggregatorTransformProps: Partial<AggregatorTransformProps> = {\r\n      binIdRange: [\r\n        binIdRange[0][0],\r\n        binIdRange[0][1],\r\n        binIdRange[1]?.[0] || 0,\r\n        binIdRange[1]?.[1] || 0\r\n      ]\r\n    };\r\n    model.shaderInputs.setProps({aggregatorTransform: aggregatorTransformProps});\r\n\r\n    // Only destroy existing buffer if it is not large enough\r\n    const binBufferByteLength = binCount * binIdRange.length * 4;\r\n    if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {\r\n      this.binBuffer?.destroy();\r\n      this.binBuffer = this.device.createBuffer({byteLength: binBufferByteLength});\r\n      transformFeedback.setBuffer('binIds', this.binBuffer);\r\n    }\r\n\r\n    const valueBufferByteLength = binCount * this.channelCount * 4;\r\n    if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {\r\n      this.valueBuffer?.destroy();\r\n      this.valueBuffer = this.device.createBuffer({byteLength: valueBufferByteLength});\r\n      transformFeedback.setBuffer('values', this.valueBuffer);\r\n    }\r\n  }\r\n\r\n  update(bins: Texture | null, operations: AggregationOperation[]) {\r\n    if (!bins) {\r\n      return;\r\n    }\r\n    const transform = this.transform;\r\n    const target = this.domainFBO;\r\n\r\n    const isCount = [0, 1, 2].map(i => (operations[i] === 'COUNT' ? 1 : 0));\r\n    const isMean = [0, 1, 2].map(i => (operations[i] === 'MEAN' ? 1 : 0));\r\n    const aggregatorTransformProps: Partial<AggregatorTransformProps> = {\r\n      isCount: isCount as NumberArray3,\r\n      isMean: isMean as NumberArray3,\r\n      bins\r\n    };\r\n    transform.model.shaderInputs.setProps({aggregatorTransform: aggregatorTransformProps});\r\n\r\n    transform.run({\r\n      id: 'gpu-aggregation-domain',\r\n      framebuffer: target,\r\n      parameters: {\r\n        viewport: [0, 0, 2, 1]\r\n      },\r\n      clearColor: [-MAX_FLOAT32, -MAX_FLOAT32, -MAX_FLOAT32, 0],\r\n      clearDepth: false,\r\n      clearStencil: false\r\n    });\r\n\r\n    // Clear the last read results. This will be lazy-populated if used.\r\n    this._domains = null;\r\n  }\r\n}\r\n\r\nfunction createTransform(device: Device, props: WebGLAggregatorProps): BufferTransform {\r\n  const vs = /* glsl */ `\\\r\n#version 300 es\r\n#define SHADER_NAME gpu-aggregation-domain-vertex\r\n\r\nuniform sampler2D bins;\r\n\r\n#if NUM_DIMS == 1\r\nout float binIds;\r\n#else\r\nout vec2 binIds;\r\n#endif\r\n\r\n#if NUM_CHANNELS == 1\r\nflat out float values;\r\n#elif NUM_CHANNELS == 2\r\nflat out vec2 values;\r\n#else\r\nflat out vec3 values;\r\n#endif\r\n\r\nconst float NAN = intBitsToFloat(-1);\r\n\r\nvoid main() {\r\n  int row = gl_VertexID / SAMPLER_WIDTH;\r\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\r\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\r\n  vec3 value3 = mix(\r\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\r\n    weights.rgb / max(weights.a, 1.0),\r\n    aggregatorTransform.isMean\r\n  );\r\n  if (weights.a == 0.0) {\r\n    value3 = vec3(NAN);\r\n  }\r\n\r\n#if NUM_DIMS == 1\r\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\r\n#else\r\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\r\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\r\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\r\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\r\n#endif\r\n\r\n#if NUM_CHANNELS == 3\r\n  values = value3;\r\n#elif NUM_CHANNELS == 2\r\n  values = value3.xy;\r\n#else\r\n  values = value3.x;\r\n#endif\r\n\r\n  gl_Position = vec4(0., 0., 0., 1.);\r\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\r\n  // See comments in fragment shader\r\n  gl_PointSize = 2.0;\r\n}\r\n`;\r\n\r\n  const fs = /* glsl */ `\\\r\n#version 300 es\r\n#define SHADER_NAME gpu-aggregation-domain-fragment\r\n\r\nprecision highp float;\r\n\r\n#if NUM_CHANNELS == 1\r\nflat in float values;\r\n#elif NUM_CHANNELS == 2\r\nflat in vec2 values;\r\n#else\r\nflat in vec3 values;\r\n#endif\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  vec3 value3;\r\n#if NUM_CHANNELS == 3\r\n  value3 = values;\r\n#elif NUM_CHANNELS == 2\r\n  value3.xy = values;\r\n#else\r\n  value3.x = values;\r\n#endif\r\n  if (isnan(value3.x)) discard;\r\n  // This shader renders into a 2x1 texture with blending=max\r\n  // The left pixel yields the max value of each channel\r\n  // The right pixel yields the min value of each channel\r\n  if (gl_FragCoord.x < 1.0) {\r\n    fragColor = vec4(value3, 1.0);\r\n  } else {\r\n    fragColor = vec4(-value3, 1.0);\r\n  }\r\n}\r\n`;\r\n\r\n  return new BufferTransform(device, {\r\n    vs,\r\n    fs,\r\n    topology: 'point-list',\r\n    modules: [aggregatorTransformUniforms],\r\n    parameters: {\r\n      blend: true,\r\n      blendColorSrcFactor: 'one',\r\n      blendColorDstFactor: 'one',\r\n      blendColorOperation: 'max',\r\n      blendAlphaSrcFactor: 'one',\r\n      blendAlphaDstFactor: 'one',\r\n      blendAlphaOperation: 'max'\r\n    },\r\n    defines: {\r\n      NUM_DIMS: props.dimensions,\r\n      NUM_CHANNELS: props.channelCount,\r\n      SAMPLER_WIDTH: TEXTURE_WIDTH\r\n    },\r\n    varyings: ['binIds', 'values'],\r\n    disableWarnings: true\r\n  });\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {WebGLBinSorter} from './webgl-bin-sorter';\r\nimport {WebGLAggregationTransform} from './webgl-aggregation-transform';\r\nimport {_deepEqual as deepEqual, log, BinaryAttribute} from '@deck.gl/core';\r\n\r\nimport type {Aggregator, AggregationProps, AggregatedBin} from '../aggregator';\r\nimport type {Device, Buffer, BufferLayout, TypedArray} from '@luma.gl/core';\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\n/** Options used to construct a new WebGLAggregator */\r\nexport type WebGLAggregatorProps = {\r\n  /** Size of bin IDs */\r\n  dimensions: 1 | 2;\r\n  /** How many properties to perform aggregation on */\r\n  channelCount: 1 | 2 | 3;\r\n  /** Buffer layout for input attributes */\r\n  bufferLayout?: BufferLayout[];\r\n  /** Define a shader function with one of the signatures\r\n   *  `void getBin(out int binId)`: if dimensions=1\r\n   *  `void getBin(out ivec2 binId)`: if dimensions=2\r\n   * And a shader function with one of the signatures\r\n   *  `void getValue(out float value)`: if channelCount=1\r\n   *  `void getValue(out vec2 value)`: if channelCount=2\r\n   *  `void getValue(out vec3 value)`: if channelCount=3\r\n   */\r\n  vs: string;\r\n  /** Shader modules\r\n   * Required to support certain layer extensions (e.g. data filter)\r\n   */\r\n  modules?: ShaderModule[];\r\n  /** Shadertool module defines */\r\n  defines?: Record<string, string | number | boolean>;\r\n} & Partial<WebGLAggregationProps>;\r\n\r\n/** Props used to run GPU aggregation, can be changed at any time */\r\ntype WebGLAggregationProps = AggregationProps & {\r\n  /** Limits of binId defined for each dimension. Ids outside of the [start, end) are ignored.\r\n   */\r\n  binIdRange: [start: number, end: number][];\r\n  /** Context props passed to the shader modules */\r\n  shaderModuleProps?: Record<string, any>;\r\n};\r\n\r\n/** An Aggregator implementation that calculates aggregation on the GPU */\r\nexport class WebGLAggregator implements Aggregator {\r\n  /** Checks if the current device supports GPU aggregation */\r\n  static isSupported(device: Device): boolean {\r\n    return (\r\n      device.features.has('float32-renderable-webgl') &&\r\n      device.features.has('texture-blend-float-webgl')\r\n    );\r\n  }\r\n\r\n  readonly dimensions: 1 | 2;\r\n  readonly channelCount: 1 | 2 | 3;\r\n  binCount: number = 0;\r\n\r\n  readonly device: Device;\r\n  props: WebGLAggregatorProps & WebGLAggregationProps;\r\n\r\n  /** Dirty flag per channel */\r\n  protected needsUpdate: boolean[];\r\n  /** Step 1. sort data points into bins, blended using an aggregation opera†ion */\r\n  protected binSorter: WebGLBinSorter;\r\n  /** Step 2. (optional) calculate the min/max across all bins */\r\n  protected aggregationTransform: WebGLAggregationTransform;\r\n\r\n  /** Cached outputs */\r\n  protected binIds: BinaryAttribute | null = null;\r\n  protected results: BinaryAttribute[] = [];\r\n\r\n  constructor(device: Device, props: WebGLAggregatorProps) {\r\n    this.device = device;\r\n    this.dimensions = props.dimensions;\r\n    this.channelCount = props.channelCount;\r\n    this.props = {\r\n      ...props,\r\n      pointCount: 0,\r\n      binIdRange: [[0, 0]],\r\n      operations: [],\r\n      attributes: {},\r\n      binOptions: {}\r\n    };\r\n    this.needsUpdate = new Array(this.channelCount).fill(true);\r\n    this.binSorter = new WebGLBinSorter(device, props);\r\n    this.aggregationTransform = new WebGLAggregationTransform(device, props);\r\n    this.setProps(props);\r\n  }\r\n\r\n  getBins(): BinaryAttribute | null {\r\n    const buffer = this.aggregationTransform.binBuffer;\r\n    if (!buffer) {\r\n      return null;\r\n    }\r\n    if (this.binIds?.buffer !== buffer) {\r\n      // deck.gl Attribute.setBinaryValue uses shallow comparison to determine if attribute value has changed\r\n      // For performance, only create a new binary attribute descriptor when Buffer changes\r\n      this.binIds = {buffer, type: 'float32', size: this.dimensions};\r\n    }\r\n    return this.binIds;\r\n  }\r\n\r\n  /** Returns an accessor to the output for a given channel. */\r\n  getResult(channel: 0 | 1 | 2): BinaryAttribute | null {\r\n    const buffer = this.aggregationTransform.valueBuffer;\r\n    if (!buffer || channel >= this.channelCount) {\r\n      return null;\r\n    }\r\n    if (this.results[channel]?.buffer !== buffer) {\r\n      this.results[channel] = {\r\n        buffer,\r\n        type: 'float32',\r\n        size: 1,\r\n        stride: this.channelCount * 4,\r\n        offset: channel * 4\r\n      };\r\n    }\r\n    return this.results[channel];\r\n  }\r\n\r\n  /** Returns the [min, max] of aggregated values for a given channel. */\r\n  getResultDomain(channel: 0 | 1 | 2): [min: number, max: number] {\r\n    return this.aggregationTransform.domains[channel];\r\n  }\r\n\r\n  /** Returns the information for a given bin. */\r\n  getBin(index: number): AggregatedBin | null {\r\n    if (index < 0 || index >= this.binCount) {\r\n      return null;\r\n    }\r\n    const {binIdRange} = this.props;\r\n    let id: number[];\r\n\r\n    if (this.dimensions === 1) {\r\n      id = [index + binIdRange[0][0]];\r\n    } else {\r\n      const [[x0, x1], [y0]] = binIdRange;\r\n      const width = x1 - x0;\r\n      id = [(index % width) + x0, Math.floor(index / width) + y0];\r\n    }\r\n\r\n    const pixel = this.binSorter.getBinValues(index);\r\n    if (!pixel) {\r\n      return null;\r\n    }\r\n    const count = pixel[3];\r\n    const value: number[] = [];\r\n    for (let channel = 0; channel < this.channelCount; channel++) {\r\n      const operation = this.props.operations[channel];\r\n      if (operation === 'COUNT') {\r\n        value[channel] = count;\r\n      } else if (count === 0) {\r\n        value[channel] = NaN;\r\n      } else {\r\n        value[channel] = operation === 'MEAN' ? pixel[channel] / count : pixel[channel];\r\n      }\r\n    }\r\n    return {id, value, count};\r\n  }\r\n\r\n  /** Release GPU resources */\r\n  destroy() {\r\n    this.binSorter.destroy();\r\n    this.aggregationTransform.destroy();\r\n  }\r\n\r\n  /** Update aggregation props. Normalize prop values and set change flags. */\r\n  // eslint-disable-next-line complexity, max-statements\r\n  setProps(props: Partial<WebGLAggregationProps>) {\r\n    const oldProps = this.props;\r\n\r\n    // Update local settings. These will set the flag this._needsUpdate\r\n    if ('binIdRange' in props && !deepEqual(props.binIdRange, oldProps.binIdRange, 2)) {\r\n      const binIdRange = props.binIdRange!;\r\n      log.assert(binIdRange.length === this.dimensions);\r\n\r\n      if (this.dimensions === 1) {\r\n        const [[x0, x1]] = binIdRange;\r\n        this.binCount = x1 - x0;\r\n      } else {\r\n        const [[x0, x1], [y0, y1]] = binIdRange;\r\n        this.binCount = (x1 - x0) * (y1 - y0);\r\n      }\r\n\r\n      this.binSorter.setDimensions(this.binCount, binIdRange);\r\n      this.aggregationTransform.setDimensions(this.binCount, binIdRange);\r\n      this.setNeedsUpdate();\r\n    }\r\n    if (props.operations) {\r\n      for (let channel = 0; channel < this.channelCount; channel++) {\r\n        if (props.operations[channel] !== oldProps.operations[channel]) {\r\n          this.setNeedsUpdate(channel);\r\n        }\r\n      }\r\n    }\r\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\r\n      this.binSorter.setModelProps({vertexCount: props.pointCount});\r\n      this.setNeedsUpdate();\r\n    }\r\n    if (props.binOptions) {\r\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\r\n        this.setNeedsUpdate();\r\n      }\r\n      this.binSorter.model.shaderInputs.setProps({binOptions: props.binOptions});\r\n    }\r\n    if (props.attributes) {\r\n      const attributeBuffers: Record<string, Buffer> = {};\r\n      const constantAttributes: Record<string, TypedArray> = {};\r\n\r\n      for (const attribute of Object.values(props.attributes)) {\r\n        for (const [attributeName, value] of Object.entries(attribute.getValue())) {\r\n          if (ArrayBuffer.isView(value)) {\r\n            constantAttributes[attributeName] = value;\r\n          } else if (value) {\r\n            attributeBuffers[attributeName] = value;\r\n          }\r\n        }\r\n      }\r\n      this.binSorter.setModelProps({attributes: attributeBuffers, constantAttributes});\r\n    }\r\n    if (props.shaderModuleProps) {\r\n      this.binSorter.setModelProps({shaderModuleProps: props.shaderModuleProps});\r\n    }\r\n\r\n    Object.assign(this.props, props);\r\n  }\r\n\r\n  /** Flags a channel to need update.\r\n   * This is called internally by setProps() if certain props change\r\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\r\n   * the underlying buffers could have been updated and require rerunning the aggregation\r\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\r\n   */\r\n  setNeedsUpdate(channel?: number) {\r\n    if (channel === undefined) {\r\n      this.needsUpdate.fill(true);\r\n    } else {\r\n      this.needsUpdate[channel] = true;\r\n    }\r\n  }\r\n\r\n  update() {}\r\n\r\n  /** Run aggregation */\r\n  preDraw() {\r\n    if (!this.needsUpdate.some(Boolean)) {\r\n      return;\r\n    }\r\n\r\n    const {operations} = this.props;\r\n    const operationsToUpdate = this.needsUpdate.map((needsUpdate, i) =>\r\n      needsUpdate ? operations[i] : null\r\n    );\r\n    // Render data to bins\r\n    this.binSorter.update(operationsToUpdate);\r\n    // Read to buffer and calculate domain\r\n    this.aggregationTransform.update(this.binSorter.texture, operations);\r\n\r\n    for (let i = 0; i < this.channelCount; i++) {\r\n      if (this.needsUpdate[i]) {\r\n        this.needsUpdate[i] = false;\r\n        this.props.onUpdate?.({channel: i});\r\n      }\r\n    }\r\n\r\n    // Uncomment to debug\r\n    // console.log('binsFBO', new Float32Array(this.device.readPixelsToArrayWebGL(this.binSorter.texture!).buffer));\r\n    // console.log('binsBuffer', new Float32Array(this.aggregationTransform.binBuffer?.readSyncWebGL().buffer!));\r\n    // console.log('resultBuffer', new Float32Array(this.aggregationTransform.valueBuffer?.readSyncWebGL().buffer!));\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {\r\n  CompositeLayer,\r\n  LayerDataSource,\r\n  LayerContext,\r\n  UpdateParameters,\r\n  CompositeLayerProps,\r\n  Attribute,\r\n  AttributeManager\r\n} from '@deck.gl/core';\r\nimport {Aggregator} from './aggregator/aggregator';\r\n\r\nexport type AggregationLayerProps<DataT> = CompositeLayerProps & {\r\n  data: LayerDataSource<DataT>;\r\n};\r\n\r\nexport default abstract class AggregationLayer<\r\n  DataT,\r\n  ExtraPropsT extends {} = {}\r\n> extends CompositeLayer<Required<AggregationLayer<DataT>> & ExtraPropsT> {\r\n  static layerName = 'AggregationLayer';\r\n\r\n  state!: {\r\n    aggregatorType: string;\r\n    aggregator: Aggregator;\r\n  };\r\n\r\n  /** Allow this layer to participates in the draw cycle */\r\n  get isDrawable() {\r\n    return true;\r\n  }\r\n\r\n  abstract getAggregatorType(): string;\r\n  /** Called to create an Aggregator instance */\r\n  abstract createAggregator(type: string): Aggregator;\r\n  /** Called when some attributes change, a chance to mark Aggregator as dirty */\r\n  abstract onAttributeChange(id: string): void;\r\n\r\n  initializeState(): void {\r\n    this.getAttributeManager()!.remove(['instancePickingColors']);\r\n  }\r\n\r\n  // Extend Layer.updateState to update the Aggregator instance\r\n  // returns true if aggregator is changed\r\n  updateState(params: UpdateParameters<this>): boolean {\r\n    super.updateState(params);\r\n\r\n    const aggregatorType = this.getAggregatorType();\r\n    if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {\r\n      this.state.aggregator?.destroy();\r\n      const aggregator = this.createAggregator(aggregatorType);\r\n      aggregator.setProps({\r\n        attributes: this.getAttributeManager()?.attributes\r\n      });\r\n      this.setState({aggregator, aggregatorType});\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Override Layer.finalizeState to dispose the Aggregator instance\r\n  finalizeState(context: LayerContext) {\r\n    super.finalizeState(context);\r\n    this.state.aggregator.destroy();\r\n  }\r\n\r\n  // Override Layer.updateAttributes to update the aggregator\r\n  protected updateAttributes(changedAttributes: {[id: string]: Attribute}) {\r\n    const {aggregator} = this.state;\r\n    aggregator.setProps({\r\n      attributes: changedAttributes\r\n    });\r\n\r\n    for (const id in changedAttributes) {\r\n      this.onAttributeChange(id);\r\n    }\r\n\r\n    // In aggregator.update() the aggregator allocates the buffers to store its output\r\n    // These buffers will be exposed by aggregator.getResults() and passed to the sublayers\r\n    // Therefore update() must be called before renderLayers()\r\n    // CPUAggregator's output is populated right here in update()\r\n    // GPUAggregator's output is pre-allocated and populated in preDraw(), see comments below\r\n    aggregator.update();\r\n  }\r\n\r\n  draw({shaderModuleProps}) {\r\n    // GPU aggregation needs `shaderModuleProps` for projection/filter uniforms which are only accessible at draw time\r\n    // GPUAggregator's Buffers are pre-allocated during `update()` and passed down to the sublayer attributes in renderLayers()\r\n    // Although the Buffers have been bound to the sublayer's Model, their content are not populated yet\r\n    // GPUAggregator.preDraw() is called in the draw cycle here right before Buffers are used by sublayer.draw()\r\n    const {aggregator} = this.state;\r\n    // @ts-expect-error only used by GPU aggregators\r\n    aggregator.setProps({shaderModuleProps});\r\n    aggregator.preDraw();\r\n  }\r\n\r\n  // override CompositeLayer._getAttributeManager to create AttributeManager instance\r\n  _getAttributeManager() {\r\n    return new AttributeManager(this.context.device, {\r\n      id: this.props.id,\r\n      stats: this.context.stats\r\n    });\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Color} from '@deck.gl/core';\r\nimport type {Device, Texture} from '@luma.gl/core';\r\nimport type {NumericArray, TypedArray, TypedArrayConstructor} from '@math.gl/types';\r\nimport type {ScaleType} from '../types';\r\n\r\nexport const defaultColorRange: Color[] = [\r\n  [255, 255, 178],\r\n  [254, 217, 118],\r\n  [254, 178, 76],\r\n  [253, 141, 60],\r\n  [240, 59, 32],\r\n  [189, 0, 38]\r\n];\r\n\r\n// Converts a colorRange array to a flat array with 4 components per color\r\nexport function colorRangeToFlatArray(\r\n  colorRange: Color[] | NumericArray,\r\n  normalize = false,\r\n  ArrayType: TypedArrayConstructor = Float32Array\r\n): TypedArray {\r\n  let flatArray: TypedArray;\r\n\r\n  if (Number.isFinite(colorRange[0])) {\r\n    // its already a flat array.\r\n    flatArray = new ArrayType(colorRange as NumericArray);\r\n  } else {\r\n    // flatten it\r\n    flatArray = new ArrayType(colorRange.length * 4);\r\n    let index = 0;\r\n\r\n    for (let i = 0; i < colorRange.length; i++) {\r\n      const color = colorRange[i];\r\n      flatArray[index++] = color[0];\r\n      flatArray[index++] = color[1];\r\n      flatArray[index++] = color[2];\r\n      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\r\n    }\r\n  }\r\n\r\n  if (normalize) {\r\n    for (let i = 0; i < flatArray.length; i++) {\r\n      flatArray[i] /= 255;\r\n    }\r\n  }\r\n  return flatArray;\r\n}\r\n\r\nexport const COLOR_RANGE_FILTER: Record<ScaleType, 'linear' | 'nearest'> = {\r\n  linear: 'linear',\r\n  quantile: 'nearest',\r\n  quantize: 'nearest',\r\n  ordinal: 'nearest'\r\n} as const;\r\n\r\nexport function updateColorRangeTexture(texture: Texture, type: ScaleType) {\r\n  texture.setSampler({\r\n    minFilter: COLOR_RANGE_FILTER[type],\r\n    magFilter: COLOR_RANGE_FILTER[type]\r\n  });\r\n}\r\n\r\nexport function createColorRangeTexture(\r\n  device: Device,\r\n  colorRange: Color[] | NumericArray,\r\n  type: ScaleType = 'linear'\r\n): Texture {\r\n  const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\r\n\r\n  return device.createTexture({\r\n    format: 'rgba8unorm',\r\n    mipmaps: false,\r\n    sampler: {\r\n      minFilter: COLOR_RANGE_FILTER[type],\r\n      magFilter: COLOR_RANGE_FILTER[type],\r\n      addressModeU: 'clamp-to-edge',\r\n      addressModeV: 'clamp-to-edge'\r\n    },\r\n    data: colors,\r\n    width: colors.length / 4,\r\n    height: 1\r\n  });\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport default /* glsl */ `\\\r\n#version 300 es\r\n#define SHADER_NAME screen-grid-layer-vertex-shader\r\n#define RANGE_COUNT 6\r\n\r\nin vec2 positions;\r\nin vec2 instancePositions;\r\nin float instanceWeights;\r\nin vec3 instancePickingColors;\r\n\r\nuniform sampler2D colorRange;\r\n\r\nout vec4 vColor;\r\n\r\nvec4 interp(float value, vec2 domain, sampler2D range) {\r\n  float r = (value - domain.x) / (domain.y - domain.x);\r\n  return texture(range, vec2(r, 0.5));\r\n}\r\n\r\nvoid main(void) {\r\n  if (isnan(instanceWeights)) {\r\n    gl_Position = vec4(0.);\r\n    return;\r\n  }\r\n\r\n  vec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;\r\n  pos.x = pos.x - 1.0;\r\n  pos.y = 1.0 - pos.y;\r\n\r\n  gl_Position = vec4(pos, 0., 1.);\r\n\r\n  vColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);\r\n  vColor.a *= layer.opacity;\r\n\r\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\r\n  picking_setPickingColor(instancePickingColors);\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\n/* fragment shader for the grid-layer */\r\nexport default /* glsl */ `\\\r\n#version 300 es\r\n#define SHADER_NAME screen-grid-layer-fragment-shader\r\n\r\nprecision highp float;\r\n\r\nin vec4 vColor;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main(void) {\r\n  fragColor = vColor;\r\n\r\n  DECKGL_FILTER_COLOR(fragColor, geometry);\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform screenGridUniforms {\r\n  vec2 cellSizeClipspace;\r\n  vec2 gridSizeClipspace;\r\n  vec2 colorDomain;\r\n} screenGrid;\r\n`;\r\n\r\nexport type ScreenGridProps = {\r\n  cellSizeClipspace: [number, number];\r\n  gridSizeClipspace: [number, number];\r\n  colorDomain: [number, number];\r\n  colorRange: Texture;\r\n};\r\n\r\nexport const screenGridUniforms = {\r\n  name: 'screenGrid',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    cellSizeClipspace: 'vec2<f32>',\r\n    gridSizeClipspace: 'vec2<f32>',\r\n    colorDomain: 'vec2<f32>'\r\n  }\r\n} as const satisfies ShaderModule<ScreenGridProps>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport {Model, Geometry} from '@luma.gl/engine';\r\nimport {Layer, picking, UpdateParameters, DefaultProps, Color} from '@deck.gl/core';\r\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\r\nimport vs from './screen-grid-layer-vertex.glsl';\r\nimport fs from './screen-grid-layer-fragment.glsl';\r\nimport {ScreenGridProps, screenGridUniforms} from './screen-grid-layer-uniforms';\r\nimport {ShaderModule} from '@luma.gl/shadertools';\r\nimport type {ScaleType} from '../common/types';\r\n\r\n/** Proprties added by ScreenGridCellLayer. */\r\nexport type _ScreenGridCellLayerProps = {\r\n  cellSizePixels: number;\r\n  cellMarginPixels: number;\r\n  colorScaleType: ScaleType;\r\n  colorDomain: () => [number, number];\r\n  colorRange?: Color[];\r\n};\r\n\r\nexport default class ScreenGridCellLayer<ExtraPropsT extends {} = {}> extends Layer<\r\n  ExtraPropsT & Required<_ScreenGridCellLayerProps>\r\n> {\r\n  static layerName = 'ScreenGridCellLayer';\r\n\r\n  state!: {\r\n    model?: Model;\r\n    colorTexture: Texture;\r\n  };\r\n\r\n  getShaders(): {vs: string; fs: string; modules: ShaderModule[]} {\r\n    return super.getShaders({vs, fs, modules: [picking, screenGridUniforms]});\r\n  }\r\n\r\n  initializeState() {\r\n    this.getAttributeManager()!.addInstanced({\r\n      instancePositions: {\r\n        size: 2,\r\n        type: 'float32',\r\n        accessor: 'getBin'\r\n      },\r\n      instanceWeights: {\r\n        size: 1,\r\n        type: 'float32',\r\n        accessor: 'getWeight'\r\n      }\r\n    });\r\n\r\n    this.state.model = this._getModel();\r\n  }\r\n\r\n  updateState(params: UpdateParameters<this>) {\r\n    super.updateState(params);\r\n\r\n    const {props, oldProps, changeFlags} = params;\r\n    const model = this.state.model!;\r\n\r\n    if (oldProps.colorRange !== props.colorRange) {\r\n      this.state.colorTexture?.destroy();\r\n      this.state.colorTexture = createColorRangeTexture(\r\n        this.context.device,\r\n        props.colorRange,\r\n        props.colorScaleType\r\n      );\r\n      const screenGridProps: Partial<ScreenGridProps> = {colorRange: this.state.colorTexture};\r\n      model.shaderInputs.setProps({screenGrid: screenGridProps});\r\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\r\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\r\n    }\r\n\r\n    if (\r\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\r\n      oldProps.cellSizePixels !== props.cellSizePixels ||\r\n      changeFlags.viewportChanged\r\n    ) {\r\n      const {width, height} = this.context.viewport;\r\n      const {cellSizePixels: gridSize, cellMarginPixels} = this.props;\r\n      const cellSize = Math.max(gridSize - cellMarginPixels, 0);\r\n\r\n      const screenGridProps: Partial<ScreenGridProps> = {\r\n        gridSizeClipspace: [(gridSize / width) * 2, (gridSize / height) * 2],\r\n        cellSizeClipspace: [(cellSize / width) * 2, (cellSize / height) * 2]\r\n      };\r\n      model.shaderInputs.setProps({screenGrid: screenGridProps});\r\n    }\r\n  }\r\n\r\n  finalizeState(context) {\r\n    super.finalizeState(context);\r\n\r\n    this.state.colorTexture?.destroy();\r\n  }\r\n\r\n  draw({uniforms}) {\r\n    const colorDomain = this.props.colorDomain();\r\n    const model = this.state.model!;\r\n\r\n    const screenGridProps: Partial<ScreenGridProps> = {colorDomain};\r\n    model.shaderInputs.setProps({screenGrid: screenGridProps});\r\n    model.draw(this.context.renderPass);\r\n  }\r\n\r\n  // Private Methods\r\n\r\n  _getModel(): Model {\r\n    return new Model(this.context.device, {\r\n      ...this.getShaders(),\r\n      id: this.props.id,\r\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\r\n      geometry: new Geometry({\r\n        topology: 'triangle-strip',\r\n        attributes: {\r\n          positions: {\r\n            value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),\r\n            size: 2\r\n          }\r\n        }\r\n      }),\r\n      isInstanced: true\r\n    });\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform binOptionsUniforms {\r\n  float cellSizePixels;\r\n} binOptions;\r\n`;\r\n\r\nexport type BinOptions = {\r\n  cellSizePixels: number;\r\n};\r\n\r\nexport const binOptionsUniforms = {\r\n  name: 'binOptions',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    cellSizePixels: 'f32'\r\n  }\r\n} as const satisfies ShaderModule<BinOptions>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {\r\n  Accessor,\r\n  Color,\r\n  GetPickingInfoParams,\r\n  CompositeLayerProps,\r\n  Layer,\r\n  project32,\r\n  LayersList,\r\n  PickingInfo,\r\n  Position,\r\n  UpdateParameters,\r\n  DefaultProps\r\n} from '@deck.gl/core';\r\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\r\nimport AggregationLayer from '../common/aggregation-layer';\r\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\r\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\r\nimport {defaultColorRange} from '../common/utils/color-utils';\r\n\r\nconst defaultProps: DefaultProps<ScreenGridLayerProps> = {\r\n  cellSizePixels: {type: 'number', value: 100, min: 1},\r\n  cellMarginPixels: {type: 'number', value: 2, min: 0},\r\n  colorRange: defaultColorRange,\r\n  colorScaleType: 'linear',\r\n  getPosition: {type: 'accessor', value: (d: any) => d.position},\r\n  getWeight: {type: 'accessor', value: 1},\r\n\r\n  gpuAggregation: true,\r\n  aggregation: 'SUM'\r\n};\r\n\r\n/** All properties supported by ScreenGridLayer. */\r\nexport type ScreenGridLayerProps<DataT = unknown> = _ScreenGridLayerProps<DataT> &\r\n  CompositeLayerProps;\r\n\r\n/** Properties added by ScreenGridLayer. */\r\nexport type _ScreenGridLayerProps<DataT> = {\r\n  /**\r\n   * Unit width/height of the bins.\r\n   * @default 100\r\n   */\r\n  cellSizePixels?: number;\r\n\r\n  /**\r\n   * Cell margin size in pixels.\r\n   * @default 2\r\n   */\r\n  cellMarginPixels?: number;\r\n\r\n  /**\r\n   * Color scale input domain. The color scale maps continues numeric domain into discrete color range.\r\n   * @default [1, max(weight)]\r\n   */\r\n  colorDomain?: [number, number] | null;\r\n\r\n  /**\r\n   * Specified as an array of colors [color1, color2, ...].\r\n   *\r\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\r\n   */\r\n  colorRange?: Color[];\r\n\r\n  /**\r\n   * Scaling function used to determine the color of the grid cell.\r\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\r\n   * @default 'quantize'\r\n   */\r\n  colorScaleType?: 'linear' | 'quantize';\r\n\r\n  /**\r\n   * Method called to retrieve the position of each object.\r\n   *\r\n   * @default d => d.position\r\n   */\r\n  getPosition?: Accessor<DataT, Position>;\r\n\r\n  /**\r\n   * The weight of each object.\r\n   *\r\n   * @default 1\r\n   */\r\n  getWeight?: Accessor<DataT, number>;\r\n\r\n  /**\r\n   * Perform aggregation is performed on GPU.\r\n   *\r\n   * @default true\r\n   */\r\n  gpuAggregation?: boolean;\r\n\r\n  /**\r\n   * Defines the type of aggregation operation\r\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\r\n   *\r\n   * @default 'SUM'\r\n   */\r\n  aggregation?: AggregationOperation;\r\n};\r\n\r\nexport type ScreenGridLayerPickingInfo<DataT> = PickingInfo<{\r\n  /** Column index of the picked cell, starting from 0 at the left of the viewport */\r\n  col: number;\r\n  /** Row index of the picked cell, starting from 0 at the top of the viewport */\r\n  row: number;\r\n  /** Aggregated value */\r\n  value: number;\r\n  /** Number of data points in the picked cell */\r\n  count: number;\r\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\r\n  pointIndices?: number[];\r\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\r\n  points?: DataT[];\r\n}>;\r\n\r\n/** Aggregates data into histogram bins and renders them as a grid. */\r\nexport default class ScreenGridLayer<\r\n  DataT = any,\r\n  ExtraProps extends {} = {}\r\n> extends AggregationLayer<DataT, ExtraProps & Required<_ScreenGridLayerProps<DataT>>> {\r\n  static layerName = 'ScreenGridLayer';\r\n  static defaultProps = defaultProps;\r\n\r\n  getAggregatorType(): string {\r\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\r\n      ? 'gpu'\r\n      : 'cpu';\r\n  }\r\n\r\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\r\n    if (type === 'cpu' || !WebGLAggregator.isSupported(this.context.device)) {\r\n      return new CPUAggregator({\r\n        dimensions: 2,\r\n        getBin: {\r\n          sources: ['positions'],\r\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\r\n            const viewport = this.context.viewport;\r\n            const p = viewport.project(positions);\r\n            const cellSizePixels: number = opts.cellSizePixels;\r\n            if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {\r\n              // Not on screen\r\n              return null;\r\n            }\r\n            return [Math.floor(p[0] / cellSizePixels), Math.floor(p[1] / cellSizePixels)];\r\n          }\r\n        },\r\n        getValue: [{sources: ['counts'], getValue: ({counts}) => counts}]\r\n      });\r\n    }\r\n    return new WebGLAggregator(this.context.device, {\r\n      dimensions: 2,\r\n      channelCount: 1,\r\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\r\n      ...super.getShaders({\r\n        modules: [project32, binOptionsUniforms],\r\n        vs: `\r\n  in vec3 positions;\r\n  in vec3 positions64Low;\r\n  in float counts;\r\n  \r\n  void getBin(out ivec2 binId) {\r\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\r\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\r\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\r\n    binId = ivec2(gridCoords);\r\n  }\r\n  void getValue(out float weight) {\r\n    weight = counts;\r\n  }\r\n  `\r\n      })\r\n    });\r\n  }\r\n\r\n  initializeState() {\r\n    super.initializeState();\r\n\r\n    const attributeManager = this.getAttributeManager()!;\r\n    attributeManager.add({\r\n      positions: {\r\n        size: 3,\r\n        accessor: 'getPosition',\r\n        type: 'float64',\r\n        fp64: this.use64bitPositions()\r\n      },\r\n      // this attribute is used in gpu aggregation path only\r\n      counts: {size: 1, accessor: 'getWeight'}\r\n    });\r\n  }\r\n\r\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\r\n    return changeFlags.somethingChanged;\r\n  }\r\n\r\n  updateState(params: UpdateParameters<this>) {\r\n    const aggregatorChanged = super.updateState(params);\r\n\r\n    const {props, oldProps, changeFlags} = params;\r\n    const {cellSizePixels, aggregation} = props;\r\n    if (\r\n      aggregatorChanged ||\r\n      changeFlags.dataChanged ||\r\n      changeFlags.updateTriggersChanged ||\r\n      changeFlags.viewportChanged ||\r\n      aggregation !== oldProps.aggregation ||\r\n      cellSizePixels !== oldProps.cellSizePixels\r\n    ) {\r\n      const {width, height} = this.context.viewport;\r\n      const {aggregator} = this.state;\r\n\r\n      if (aggregator instanceof WebGLAggregator) {\r\n        aggregator.setProps({\r\n          binIdRange: [\r\n            [0, Math.ceil(width / cellSizePixels)],\r\n            [0, Math.ceil(height / cellSizePixels)]\r\n          ]\r\n        });\r\n      }\r\n\r\n      aggregator.setProps({\r\n        pointCount: this.getNumInstances(),\r\n        operations: [aggregation],\r\n        binOptions: {\r\n          cellSizePixels\r\n        }\r\n      });\r\n    }\r\n\r\n    if (changeFlags.viewportChanged) {\r\n      // Rerun aggregation on viewport change\r\n      this.state.aggregator.setNeedsUpdate();\r\n    }\r\n    return aggregatorChanged;\r\n  }\r\n\r\n  onAttributeChange(id: string) {\r\n    const {aggregator} = this.state;\r\n    switch (id) {\r\n      case 'positions':\r\n        aggregator.setNeedsUpdate();\r\n        break;\r\n\r\n      case 'counts':\r\n        aggregator.setNeedsUpdate(0);\r\n        break;\r\n\r\n      default:\r\n      // This should not happen\r\n    }\r\n  }\r\n\r\n  renderLayers(): LayersList | Layer | null {\r\n    const {aggregator} = this.state;\r\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\r\n    const binAttribute = aggregator.getBins();\r\n    const weightAttribute = aggregator.getResult(0);\r\n\r\n    return new CellLayerClass(\r\n      this.props,\r\n      this.getSubLayerProps({\r\n        id: 'cell-layer'\r\n      }),\r\n      {\r\n        data: {\r\n          length: aggregator.binCount,\r\n          attributes: {\r\n            getBin: binAttribute,\r\n            getWeight: weightAttribute\r\n          }\r\n        },\r\n        // Data has changed shallowly, but we likely don't need to update the attributes\r\n        dataComparator: (data, oldData) => data.length === oldData.length,\r\n        updateTriggers: {\r\n          getBin: [binAttribute],\r\n          getWeight: [weightAttribute]\r\n        },\r\n        parameters: {\r\n          depthWriteEnabled: false,\r\n          ...this.props.parameters\r\n        },\r\n        // Evaluate domain at draw() time\r\n        colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),\r\n        // Extensions are already handled by the GPUAggregator, do not pass it down\r\n        extensions: []\r\n      }\r\n    );\r\n  }\r\n\r\n  getPickingInfo(params: GetPickingInfoParams): ScreenGridLayerPickingInfo<DataT> {\r\n    const info: ScreenGridLayerPickingInfo<DataT> = params.info;\r\n    const {index} = info;\r\n    if (index >= 0) {\r\n      const bin = this.state.aggregator.getBin(index);\r\n      let object: ScreenGridLayerPickingInfo<DataT>['object'];\r\n      if (bin) {\r\n        object = {\r\n          col: bin.id[0],\r\n          row: bin.id[1],\r\n          value: bin.value[0],\r\n          count: bin.count\r\n        };\r\n        if (bin.pointIndices) {\r\n          object.pointIndices = bin.pointIndices;\r\n          object.points = Array.isArray(this.props.data)\r\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\r\n            : [];\r\n        }\r\n      }\r\n      info.object = object;\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {BinaryAttribute} from '@deck.gl/core';\r\nimport type {ScaleType} from '../types';\r\n\r\ntype ScaleProps = {\r\n  scaleType: ScaleType;\r\n  /** Trim the lower end of the domain by this percentile. Set to `0` to disable. */\r\n  lowerPercentile: number;\r\n  /** Trim the upper end of the domain by this percentile. Set to `100` to disable. */\r\n  upperPercentile: number;\r\n};\r\n\r\n/** Applies a scale to BinaryAttribute */\r\nexport class AttributeWithScale {\r\n  /** Input values accessor. Has either a `value` (CPU aggregation) or a `buffer` (GPU aggregation) */\r\n  private readonly input: BinaryAttribute;\r\n  private readonly inputLength: number;\r\n\r\n  private props: ScaleProps = {\r\n    scaleType: 'linear',\r\n    lowerPercentile: 0,\r\n    upperPercentile: 100\r\n  };\r\n\r\n  // cached calculations\r\n  private _percentile?: {attribute: BinaryAttribute; domain: number[]};\r\n  private _ordinal?: {attribute: BinaryAttribute; domain: number[]};\r\n\r\n  /** Output values accessor */\r\n  attribute: BinaryAttribute;\r\n  /** [min, max] of attribute values, or null if unknown */\r\n  domain: [number, number] | null = null;\r\n  /** Valid domain if lower/upper percentile are defined */\r\n  cutoff: [number, number] | null = null;\r\n\r\n  constructor(input: BinaryAttribute, inputLength: number) {\r\n    this.input = input;\r\n    this.inputLength = inputLength;\r\n    // No processing is needed with the default scale\r\n    this.attribute = input;\r\n  }\r\n\r\n  private getScalePercentile() {\r\n    if (!this._percentile) {\r\n      const value = getAttributeValue(this.input, this.inputLength);\r\n      this._percentile = applyScaleQuantile(value);\r\n    }\r\n    return this._percentile;\r\n  }\r\n\r\n  private getScaleOrdinal() {\r\n    if (!this._ordinal) {\r\n      const value = getAttributeValue(this.input, this.inputLength);\r\n      this._ordinal = applyScaleOrdinal(value);\r\n    }\r\n    return this._ordinal;\r\n  }\r\n\r\n  /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */\r\n  private getCutoff({\r\n    scaleType,\r\n    lowerPercentile,\r\n    upperPercentile\r\n  }: ScaleProps): [number, number] | null {\r\n    if (scaleType === 'quantile') {\r\n      return [lowerPercentile, upperPercentile - 1];\r\n    }\r\n\r\n    if (lowerPercentile > 0 || upperPercentile < 100) {\r\n      const {domain: thresholds} = this.getScalePercentile();\r\n      let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;\r\n      let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;\r\n\r\n      if (scaleType === 'ordinal') {\r\n        const {domain: sortedUniqueValues} = this.getScaleOrdinal();\r\n        lowValue = sortedUniqueValues.findIndex(x => x >= lowValue);\r\n        highValue = sortedUniqueValues.findIndex(x => x > highValue) - 1;\r\n        if (highValue === -2) {\r\n          highValue = sortedUniqueValues.length - 1;\r\n        }\r\n      }\r\n      return [lowValue, highValue];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  update(props: ScaleProps) {\r\n    const oldProps = this.props;\r\n\r\n    if (props.scaleType !== oldProps.scaleType) {\r\n      switch (props.scaleType) {\r\n        case 'quantile': {\r\n          const {attribute} = this.getScalePercentile();\r\n          this.attribute = attribute;\r\n          this.domain = [0, 99];\r\n          break;\r\n        }\r\n        case 'ordinal': {\r\n          const {attribute, domain} = this.getScaleOrdinal();\r\n          this.attribute = attribute;\r\n          this.domain = [0, domain.length - 1];\r\n          break;\r\n        }\r\n\r\n        default:\r\n          this.attribute = this.input;\r\n          this.domain = null;\r\n      }\r\n    }\r\n    if (\r\n      props.scaleType !== oldProps.scaleType ||\r\n      props.lowerPercentile !== oldProps.lowerPercentile ||\r\n      props.upperPercentile !== oldProps.upperPercentile\r\n    ) {\r\n      this.cutoff = this.getCutoff(props);\r\n    }\r\n    this.props = props;\r\n    return this;\r\n  }\r\n}\r\n\r\n/**\r\n * Transform an array of values to ordinal indices\r\n */\r\nexport function applyScaleOrdinal(values: Float32Array): {\r\n  attribute: BinaryAttribute;\r\n  domain: number[];\r\n} {\r\n  const uniqueValues = new Set<number>();\r\n  for (const x of values) {\r\n    if (Number.isFinite(x)) {\r\n      uniqueValues.add(x);\r\n    }\r\n  }\r\n  const sortedUniqueValues = Array.from(uniqueValues).sort();\r\n  const domainMap = new Map();\r\n  for (let i = 0; i < sortedUniqueValues.length; i++) {\r\n    domainMap.set(sortedUniqueValues[i], i);\r\n  }\r\n\r\n  return {\r\n    attribute: {\r\n      value: values.map(x => (Number.isFinite(x) ? domainMap.get(x) : NaN)),\r\n      type: 'float32',\r\n      size: 1\r\n    },\r\n    domain: sortedUniqueValues\r\n  };\r\n}\r\n\r\n/**\r\n * Transform an array of values to percentiles\r\n */\r\nexport function applyScaleQuantile(\r\n  values: Float32Array,\r\n  rangeLength = 100\r\n): {\r\n  attribute: BinaryAttribute;\r\n  domain: number[];\r\n} {\r\n  const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);\r\n  let i = 0;\r\n  const n = Math.max(1, rangeLength);\r\n  const thresholds: number[] = new Array(n - 1);\r\n  while (++i < n) {\r\n    thresholds[i - 1] = threshold(sortedValues, i / n);\r\n  }\r\n  return {\r\n    attribute: {\r\n      value: values.map(x => (Number.isFinite(x) ? bisectRight(thresholds, x) : NaN)),\r\n      type: 'float32',\r\n      size: 1\r\n    },\r\n    domain: thresholds\r\n  };\r\n}\r\n\r\nfunction getAttributeValue(attribute: BinaryAttribute, length: number): Float32Array {\r\n  const elementStride = (attribute.stride ?? 4) / 4;\r\n  const elementOffset = (attribute.offset ?? 0) / 4;\r\n  let value = attribute.value as Float32Array;\r\n  if (!value) {\r\n    const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);\r\n    if (bytes) {\r\n      value = new Float32Array(bytes.buffer);\r\n      attribute.value = value;\r\n    }\r\n  }\r\n\r\n  if (elementStride === 1) {\r\n    return value.subarray(0, length);\r\n  }\r\n  const result = new Float32Array(length);\r\n  for (let i = 0; i < length; i++) {\r\n    result[i] = value[i * elementStride + elementOffset];\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction ascending(a: number, b: number): number {\r\n  return a - b;\r\n}\r\n\r\nfunction threshold(domain: number[], fraction: number): number {\r\n  const domainLength = domain.length;\r\n  if (fraction <= 0 || domainLength < 2) {\r\n    return domain[0];\r\n  }\r\n  if (fraction >= 1) {\r\n    return domain[domainLength - 1];\r\n  }\r\n\r\n  const domainFraction = (domainLength - 1) * fraction;\r\n  const lowIndex = Math.floor(domainFraction);\r\n  const low = domain[lowIndex];\r\n  const high = domain[lowIndex + 1];\r\n  return low + (high - low) * (domainFraction - lowIndex);\r\n}\r\n\r\nfunction bisectRight(a: number[], x: number): number {\r\n  let lo = 0;\r\n  let hi = a.length;\r\n  while (lo < hi) {\r\n    const mid = (lo + hi) >>> 1;\r\n    if (a[mid] > x) {\r\n      hi = mid;\r\n    } else {\r\n      lo = mid + 1;\r\n    }\r\n  }\r\n  return lo;\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\n/** Utility to estimate binIdRange as expected by AggregatorProps */\r\nexport function getBinIdRange({\r\n  dataBounds,\r\n  getBinId,\r\n  padding = 0\r\n}: {\r\n  /** Bounds of the input data */\r\n  dataBounds: [min: number[], max: number[]];\r\n  /** Given a data point, returns the bin id that it belongs to */\r\n  getBinId: (p: number[]) => number[];\r\n  /** Add a border around the result to avoid clipping */\r\n  padding?: number;\r\n}): [number, number][] {\r\n  const corners = [\r\n    dataBounds[0],\r\n    dataBounds[1],\r\n    [dataBounds[0][0], dataBounds[1][1]],\r\n    [dataBounds[1][0], dataBounds[0][1]]\r\n  ].map(p => getBinId(p));\r\n\r\n  const minX = Math.min(...corners.map(p => p[0])) - padding;\r\n  const minY = Math.min(...corners.map(p => p[1])) - padding;\r\n  const maxX = Math.max(...corners.map(p => p[0])) + padding + 1;\r\n  const maxY = Math.max(...corners.map(p => p[1])) + padding + 1;\r\n\r\n  return [\r\n    [minX, maxX],\r\n    [minY, maxY]\r\n  ];\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nconst THIRD_PI = Math.PI / 3;\r\nconst DIST_X = 2 * Math.sin(THIRD_PI);\r\nconst DIST_Y = 1.5;\r\n\r\ntype HexBin = [i: number, j: number];\r\ntype Point = [x: number, y: number];\r\n\r\nexport const HexbinVertices = Array.from({length: 6}, (_, i) => {\r\n  const angle = i * THIRD_PI;\r\n  return [Math.sin(angle), -Math.cos(angle)];\r\n});\r\n\r\n/**\r\n * Adapted from d3-hexbin\r\n * Copyright Mike Bostock, 2012-2016\r\n   All rights reserved.\r\n * https://github.com/d3/d3-hexbin/blob/master/src/hexbin.js\r\n *\r\n * Returns the hexbin that a point (x,y) falls into\r\n */\r\nexport function pointToHexbin([px, py]: Point, radius: number): HexBin {\r\n  let pj = Math.round((py = py / radius / DIST_Y));\r\n  let pi = Math.round((px = px / radius / DIST_X - (pj & 1) / 2));\r\n  const py1 = py - pj;\r\n\r\n  if (Math.abs(py1) * 3 > 1) {\r\n    const px1 = px - pi;\r\n    const pi2 = pi + (px < pi ? -1 : 1) / 2;\r\n    const pj2 = pj + (py < pj ? -1 : 1);\r\n    const px2 = px - pi2;\r\n    const py2 = py - pj2;\r\n    if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) {\r\n      pi = pi2 + (pj & 1 ? 1 : -1) / 2;\r\n      pj = pj2;\r\n    }\r\n  }\r\n  return [pi, pj];\r\n}\r\n\r\nexport const pointToHexbinGLSL = /* glsl */ `\r\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\r\n\r\nivec2 pointToHexbin(vec2 p, float radius) {\r\n  p /= radius * DIST;\r\n  float pj = round(p.y);\r\n  float pjm2 = mod(pj, 2.0);\r\n  p.x -= pjm2 * 0.5;\r\n  float pi = round(p.x);\r\n  vec2 d1 = p - vec2(pi, pj);\r\n\r\n  if (abs(d1.y) * 3. > 1.) {\r\n    vec2 v2 = step(0.0, d1) - 0.5;\r\n    v2.y *= 2.0;\r\n    vec2 d2 = d1 - v2;\r\n    if (dot(d1, d1) > dot(d2, d2)) {\r\n      pi += v2.x + pjm2 - 0.5;\r\n      pj += v2.y;\r\n    }\r\n  }\r\n  return ivec2(pi, pj);\r\n}\r\n`;\r\n\r\nexport function getHexbinCentroid([i, j]: HexBin, radius: number): Point {\r\n  return [(i + (j & 1) / 2) * radius * DIST_X, j * radius * DIST_Y];\r\n}\r\n\r\nexport const getHexbinCentroidGLSL = `\r\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\r\n\r\nvec2 hexbinCentroid(vec2 binId, float radius) {\r\n  binId.x += fract(binId.y * 0.5);\r\n  return binId * DIST * radius;\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {getHexbinCentroidGLSL} from './hexbin';\r\n\r\nexport default /* glsl */ `\\\r\n#version 300 es\r\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\r\n\r\nin vec3 positions;\r\nin vec3 normals;\r\n\r\nin vec2 instancePositions;\r\nin float instanceElevationValues;\r\nin float instanceColorValues;\r\nin vec3 instancePickingColors;\r\n\r\nuniform sampler2D colorRange;\r\n\r\n// Result\r\nout vec4 vColor;\r\n\r\n${getHexbinCentroidGLSL}\r\n\r\nfloat interp(float value, vec2 domain, vec2 range) {\r\n  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\r\n  return mix(range.x, range.y, r);\r\n}\r\n\r\nvec4 interp(float value, vec2 domain, sampler2D range) {\r\n  float r = (value - domain.x) / (domain.y - domain.x);\r\n  return texture(range, vec2(r, 0.5));\r\n}\r\n\r\nvoid main(void) {\r\n  geometry.pickingColor = instancePickingColors;\r\n\r\n  if (isnan(instanceColorValues) ||\r\n    instanceColorValues < hexagon.colorDomain.z ||\r\n    instanceColorValues > hexagon.colorDomain.w ||\r\n    instanceElevationValues < hexagon.elevationDomain.z ||\r\n    instanceElevationValues > hexagon.elevationDomain.w\r\n  ) {\r\n    gl_Position = vec4(0.);\r\n    return;\r\n  }\r\n  \r\n  vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);\r\n  commonPosition += positions.xy * column.radius * column.coverage;\r\n  geometry.position = vec4(commonPosition, 0.0, 1.0);\r\n  geometry.normal = project_normal(normals);\r\n\r\n  // calculate z, if 3d not enabled set to 0\r\n  float elevation = 0.0;\r\n  if (column.extruded) {\r\n    elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);\r\n    elevation = project_size(elevation);\r\n    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\r\n    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\r\n  }\r\n\r\n  gl_Position = project_common_position_to_clipspace(geometry.position);\r\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\r\n\r\n  vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);\r\n  vColor.a *= layer.opacity;\r\n  if (column.extruded) {\r\n    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\r\n  }\r\n  DECKGL_FILTER_COLOR(vColor, geometry);\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform hexagonUniforms {\r\n  vec4 colorDomain;\r\n  vec4 elevationDomain;\r\n  vec2 elevationRange;\r\n  vec2 originCommon;\r\n} hexagon;\r\n`;\r\n\r\nexport type HexagonProps = {\r\n  colorDomain: [number, number, number, number];\r\n  colorRange: Texture;\r\n  elevationDomain: [number, number, number, number];\r\n  elevationRange: [number, number];\r\n  originCommon: [number, number];\r\n};\r\n\r\nexport const hexagonUniforms = {\r\n  name: 'hexagon',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    colorDomain: 'vec4<f32>',\r\n    elevationDomain: 'vec4<f32>',\r\n    elevationRange: 'vec2<f32>',\r\n    originCommon: 'vec2<f32>'\r\n  }\r\n} as const satisfies ShaderModule<HexagonProps>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport {UpdateParameters, Color} from '@deck.gl/core';\r\nimport {ColumnLayer} from '@deck.gl/layers';\r\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\r\nimport vs from './hexagon-cell-layer-vertex.glsl';\r\nimport {HexagonProps, hexagonUniforms} from './hexagon-layer-uniforms';\r\nimport type {ScaleType} from '../common/types';\r\n\r\n/** Proprties added by HexagonCellLayer. */\r\nexport type _HexagonCellLayerProps = {\r\n  hexOriginCommon: [number, number];\r\n  colorDomain: [number, number];\r\n  colorCutoff: [number, number] | null;\r\n  colorRange: Color[];\r\n  colorScaleType: ScaleType;\r\n  elevationDomain: [number, number];\r\n  elevationCutoff: [number, number] | null;\r\n  elevationRange: [number, number];\r\n};\r\n\r\nexport default class HexagonCellLayer<ExtraPropsT extends {} = {}> extends ColumnLayer<\r\n  null,\r\n  ExtraPropsT & Required<_HexagonCellLayerProps>\r\n> {\r\n  static layerName = 'HexagonCellLayer';\r\n\r\n  state!: ColumnLayer['state'] & {\r\n    colorTexture: Texture;\r\n  };\r\n\r\n  getShaders() {\r\n    const shaders = super.getShaders();\r\n    shaders.modules.push(hexagonUniforms);\r\n    return {...shaders, vs};\r\n  }\r\n\r\n  initializeState() {\r\n    super.initializeState();\r\n\r\n    const attributeManager = this.getAttributeManager()!;\r\n    attributeManager.remove([\r\n      'instanceElevations',\r\n      'instanceFillColors',\r\n      'instanceLineColors',\r\n      'instanceStrokeWidths'\r\n    ]);\r\n    attributeManager.addInstanced({\r\n      instancePositions: {\r\n        size: 2,\r\n        type: 'float32',\r\n        accessor: 'getBin'\r\n      },\r\n      instanceColorValues: {\r\n        size: 1,\r\n        type: 'float32',\r\n        accessor: 'getColorValue'\r\n      },\r\n      instanceElevationValues: {\r\n        size: 1,\r\n        type: 'float32',\r\n        accessor: 'getElevationValue'\r\n      }\r\n    });\r\n  }\r\n\r\n  updateState(params: UpdateParameters<this>) {\r\n    super.updateState(params);\r\n\r\n    const {props, oldProps} = params;\r\n    const model = this.state.fillModel!;\r\n\r\n    if (oldProps.colorRange !== props.colorRange) {\r\n      this.state.colorTexture?.destroy();\r\n      this.state.colorTexture = createColorRangeTexture(\r\n        this.context.device,\r\n        props.colorRange,\r\n        props.colorScaleType\r\n      );\r\n      const hexagonProps: Partial<HexagonProps> = {colorRange: this.state.colorTexture};\r\n      model.shaderInputs.setProps({hexagon: hexagonProps});\r\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\r\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\r\n    }\r\n  }\r\n\r\n  finalizeState(context) {\r\n    super.finalizeState(context);\r\n\r\n    this.state.colorTexture?.destroy();\r\n  }\r\n\r\n  draw({uniforms}) {\r\n    const {\r\n      radius,\r\n      hexOriginCommon,\r\n      elevationRange,\r\n      elevationScale,\r\n      extruded,\r\n      coverage,\r\n      colorDomain,\r\n      elevationDomain\r\n    } = this.props;\r\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\r\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\r\n    const fillModel = this.state.fillModel!;\r\n\r\n    if (fillModel.vertexArray.indexBuffer) {\r\n      // indices are for drawing wireframe, disable them\r\n      // TODO - this should be handled in ColumnLayer?\r\n      fillModel.setIndexBuffer(null);\r\n    }\r\n    fillModel.setVertexCount(this.state.fillVertexCount);\r\n\r\n    const hexagonProps: Omit<HexagonProps, 'colorRange'> = {\r\n      colorDomain: [\r\n        Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\r\n        Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\r\n        Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\r\n        Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\r\n      ],\r\n      elevationDomain: [\r\n        Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\r\n        Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\r\n        Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\r\n        Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\r\n      ],\r\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\r\n      originCommon: hexOriginCommon\r\n    };\r\n\r\n    fillModel.shaderInputs.setProps({\r\n      column: {extruded, coverage, radius},\r\n      hexagon: hexagonProps\r\n    });\r\n    fillModel.draw(this.context.renderPass);\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\nimport {NumberArray2} from '@math.gl/core';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform binOptionsUniforms {\r\n  vec2 hexOriginCommon;\r\n  float radiusCommon;\r\n} binOptions;\r\n`;\r\n\r\nexport type BinOptions = {\r\n  hexOriginCommon: NumberArray2;\r\n  radiusCommon: number;\r\n};\r\n\r\nexport const binOptionsUniforms = {\r\n  name: 'binOptions',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    hexOriginCommon: 'vec2<f32>',\r\n    radiusCommon: 'f32'\r\n  }\r\n} as const satisfies ShaderModule<BinOptions>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {\r\n  log,\r\n  Accessor,\r\n  Color,\r\n  GetPickingInfoParams,\r\n  CompositeLayerProps,\r\n  createIterable,\r\n  Layer,\r\n  Material,\r\n  project32,\r\n  LayersList,\r\n  PickingInfo,\r\n  Position,\r\n  Viewport,\r\n  UpdateParameters,\r\n  DefaultProps\r\n} from '@deck.gl/core';\r\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\r\nimport AggregationLayer from '../common/aggregation-layer';\r\nimport {AggregateAccessor} from '../common/types';\r\nimport {defaultColorRange} from '../common/utils/color-utils';\r\nimport {AttributeWithScale} from '../common/utils/scale-utils';\r\nimport {getBinIdRange} from '../common/utils/bounds-utils';\r\n\r\nimport HexagonCellLayer from './hexagon-cell-layer';\r\nimport {pointToHexbin, HexbinVertices, getHexbinCentroid, pointToHexbinGLSL} from './hexbin';\r\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-function\r\nfunction noop() {}\r\n\r\nconst defaultProps: DefaultProps<HexagonLayerProps> = {\r\n  gpuAggregation: true,\r\n\r\n  // color\r\n  colorDomain: null,\r\n  colorRange: defaultColorRange,\r\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\r\n  getColorWeight: {type: 'accessor', value: 1},\r\n  colorAggregation: 'SUM',\r\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\r\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\r\n  colorScaleType: 'quantize',\r\n  onSetColorDomain: noop,\r\n\r\n  // elevation\r\n  elevationDomain: null,\r\n  elevationRange: [0, 1000],\r\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\r\n  getElevationWeight: {type: 'accessor', value: 1},\r\n  elevationAggregation: 'SUM',\r\n  elevationScale: {type: 'number', min: 0, value: 1},\r\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\r\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\r\n  elevationScaleType: 'linear',\r\n  onSetElevationDomain: noop,\r\n\r\n  // hexbin\r\n  radius: {type: 'number', min: 1, value: 1000},\r\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\r\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\r\n  hexagonAggregator: {type: 'function', optional: true, value: null},\r\n  extruded: false,\r\n\r\n  // Optional material for 'lighting' shader module\r\n  material: true\r\n};\r\n\r\n/** All properties supported by HexagonLayer. */\r\nexport type HexagonLayerProps<DataT = unknown> = _HexagonLayerProps<DataT> & CompositeLayerProps;\r\n\r\n/** Properties added by HexagonLayer. */\r\ntype _HexagonLayerProps<DataT> = {\r\n  /**\r\n   * Radius of hexagon bin in meters. The hexagons are pointy-topped (rather than flat-topped).\r\n   * @default 1000\r\n   */\r\n  radius?: number;\r\n\r\n  /**\r\n   * Custom accessor to retrieve a hexagonal bin index from each data object.\r\n   * Not supported by GPU aggregation.\r\n   * @default null\r\n   */\r\n  hexagonAggregator?: ((position: number[], radius: number) => [number, number]) | null;\r\n\r\n  /**\r\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\r\n   * @default [min(colorWeight), max(colorWeight)]\r\n   */\r\n  colorDomain?: [number, number] | null;\r\n\r\n  /**\r\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\r\n   */\r\n  colorRange?: Color[];\r\n\r\n  /**\r\n   * Cell size multiplier, clamped between 0 - 1.\r\n   * @default 1\r\n   */\r\n  coverage?: number;\r\n\r\n  /**\r\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\r\n   * @default [0, max(elevationWeight)]\r\n   */\r\n  elevationDomain?: [number, number] | null;\r\n\r\n  /**\r\n   * Elevation scale output range.\r\n   * @default [0, 1000]\r\n   */\r\n  elevationRange?: [number, number];\r\n\r\n  /**\r\n   * Cell elevation multiplier.\r\n   * @default 1\r\n   */\r\n  elevationScale?: number;\r\n\r\n  /**\r\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\r\n   * @default true\r\n   */\r\n  extruded?: boolean;\r\n\r\n  /**\r\n   * Filter cells and re-calculate color by `upperPercentile`.\r\n   * Cells with value larger than the upperPercentile will be hidden.\r\n   * @default 100\r\n   */\r\n  upperPercentile?: number;\r\n\r\n  /**\r\n   * Filter cells and re-calculate color by `lowerPercentile`.\r\n   * Cells with value smaller than the lowerPercentile will be hidden.\r\n   * @default 0\r\n   */\r\n  lowerPercentile?: number;\r\n\r\n  /**\r\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\r\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\r\n   * @default 100\r\n   */\r\n  elevationUpperPercentile?: number;\r\n\r\n  /**\r\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\r\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\r\n   * @default 0\r\n   */\r\n  elevationLowerPercentile?: number;\r\n\r\n  /**\r\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\r\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\r\n   * @default 'quantize'\r\n   */\r\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\r\n\r\n  /**\r\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\r\n   * Supported Values are 'linear' and 'quantile'.\r\n   * @default 'linear'\r\n   */\r\n  elevationScaleType?: 'linear';\r\n\r\n  /**\r\n   * Material settings for lighting effect. Applies if `extruded: true`.\r\n   *\r\n   * @default true\r\n   * @see https://deck.gl/docs/developer-guide/using-lighting\r\n   */\r\n  material?: Material;\r\n\r\n  /**\r\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\r\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\r\n   *\r\n   * @default 'SUM'\r\n   */\r\n  colorAggregation?: AggregationOperation;\r\n\r\n  /**\r\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\r\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\r\n   *\r\n   * @default 'SUM'\r\n   */\r\n  elevationAggregation?: AggregationOperation;\r\n\r\n  /**\r\n   * Method called to retrieve the position of each object.\r\n   * @default object => object.position\r\n   */\r\n  getPosition?: Accessor<DataT, Position>;\r\n\r\n  /**\r\n   * The weight of a data object used to calculate the color value for a cell.\r\n   * @default 1\r\n   */\r\n  getColorWeight?: Accessor<DataT, number>;\r\n\r\n  /**\r\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\r\n   * Not supported by GPU aggregation.\r\n   * @default null\r\n   */\r\n  getColorValue?: AggregateAccessor<DataT> | null;\r\n\r\n  /**\r\n   * The weight of a data object used to calculate the elevation value for a cell.\r\n   * @default 1\r\n   */\r\n  getElevationWeight?: Accessor<DataT, number>;\r\n\r\n  /**\r\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\r\n   * Not supported by GPU aggregation.\r\n   * @default null\r\n   */\r\n  getElevationValue?: AggregateAccessor<DataT> | null;\r\n\r\n  /**\r\n   * This callback will be called when bin color domain has been calculated.\r\n   * @default () => {}\r\n   */\r\n  onSetColorDomain?: (minMax: [number, number]) => void;\r\n\r\n  /**\r\n   * This callback will be called when bin elevation domain has been calculated.\r\n   * @default () => {}\r\n   */\r\n  onSetElevationDomain?: (minMax: [number, number]) => void;\r\n\r\n  /**\r\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\r\n   * @default true\r\n   */\r\n  gpuAggregation?: boolean;\r\n};\r\n\r\nexport type HexagonLayerPickingInfo<DataT> = PickingInfo<{\r\n  /** Column index of the picked cell */\r\n  col: number;\r\n  /** Row index of the picked cell */\r\n  row: number;\r\n  /** Aggregated color value, as determined by `getColorWeight` and `colorAggregation` */\r\n  colorValue: number;\r\n  /** Aggregated elevation value, as determined by `getElevationWeight` and `elevationAggregation` */\r\n  elevationValue: number;\r\n  /** Number of data points in the picked cell */\r\n  count: number;\r\n  /** Centroid of the hexagon */\r\n  position: [number, number];\r\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\r\n  pointIndices?: number[];\r\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\r\n  points?: DataT[];\r\n}>;\r\n\r\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\r\nexport default class HexagonLayer<\r\n  DataT = any,\r\n  ExtraPropsT extends {} = {}\r\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HexagonLayerProps<DataT>>> {\r\n  static layerName = 'HexagonLayer';\r\n  static defaultProps = defaultProps;\r\n\r\n  state!: AggregationLayer<DataT>['state'] &\r\n    BinOptions & {\r\n      // Needed if getColorValue, getElevationValue are used\r\n      dataAsArray?: DataT[];\r\n\r\n      colors?: AttributeWithScale;\r\n      elevations?: AttributeWithScale;\r\n\r\n      binIdRange: [number, number][];\r\n      aggregatorViewport: Viewport;\r\n    };\r\n\r\n  getAggregatorType(): string {\r\n    const {gpuAggregation, hexagonAggregator, getColorValue, getElevationValue} = this.props;\r\n    if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {\r\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\r\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\r\n      return 'cpu';\r\n    }\r\n\r\n    if (\r\n      // GPU aggregation is requested\r\n      gpuAggregation &&\r\n      // GPU aggregation is supported by the device\r\n      WebGLAggregator.isSupported(this.context.device)\r\n    ) {\r\n      return 'gpu';\r\n    }\r\n    return 'cpu';\r\n  }\r\n\r\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\r\n    if (type === 'cpu') {\r\n      const {hexagonAggregator, radius} = this.props;\r\n      return new CPUAggregator({\r\n        dimensions: 2,\r\n        getBin: {\r\n          sources: ['positions'],\r\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\r\n            if (hexagonAggregator) {\r\n              return hexagonAggregator(positions, radius);\r\n            }\r\n            const viewport = this.state.aggregatorViewport;\r\n            // project to common space\r\n            const p = viewport.projectPosition(positions);\r\n            const {radiusCommon, hexOriginCommon} = opts;\r\n            return pointToHexbin(\r\n              [p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]],\r\n              radiusCommon\r\n            );\r\n          }\r\n        },\r\n        getValue: [\r\n          {sources: ['colorWeights'], getValue: ({colorWeights}) => colorWeights},\r\n          {sources: ['elevationWeights'], getValue: ({elevationWeights}) => elevationWeights}\r\n        ]\r\n      });\r\n    }\r\n    return new WebGLAggregator(this.context.device, {\r\n      dimensions: 2,\r\n      channelCount: 2,\r\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\r\n      ...super.getShaders({\r\n        modules: [project32, binOptionsUniforms],\r\n        vs: /* glsl */ `\r\n  in vec3 positions;\r\n  in vec3 positions64Low;\r\n  in float colorWeights;\r\n  in float elevationWeights;\r\n  \r\n  ${pointToHexbinGLSL}\r\n\r\n  void getBin(out ivec2 binId) {\r\n    vec3 positionCommon = project_position(positions, positions64Low);\r\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\r\n  }\r\n  void getValue(out vec2 value) {\r\n    value = vec2(colorWeights, elevationWeights);\r\n  }\r\n  `\r\n      })\r\n    });\r\n  }\r\n\r\n  initializeState() {\r\n    super.initializeState();\r\n\r\n    const attributeManager = this.getAttributeManager()!;\r\n    attributeManager.add({\r\n      positions: {\r\n        size: 3,\r\n        accessor: 'getPosition',\r\n        type: 'float64',\r\n        fp64: this.use64bitPositions()\r\n      },\r\n      colorWeights: {size: 1, accessor: 'getColorWeight'},\r\n      elevationWeights: {size: 1, accessor: 'getElevationWeight'}\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line complexity\r\n  updateState(params: UpdateParameters<this>) {\r\n    const aggregatorChanged = super.updateState(params);\r\n\r\n    const {props, oldProps, changeFlags} = params;\r\n    const {aggregator} = this.state;\r\n    if (\r\n      (changeFlags.dataChanged || !this.state.dataAsArray) &&\r\n      (props.getColorValue || props.getElevationValue)\r\n    ) {\r\n      // Convert data to array\r\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\r\n    }\r\n    if (\r\n      aggregatorChanged ||\r\n      changeFlags.dataChanged ||\r\n      props.radius !== oldProps.radius ||\r\n      props.getColorValue !== oldProps.getColorValue ||\r\n      props.getElevationValue !== oldProps.getElevationValue ||\r\n      props.colorAggregation !== oldProps.colorAggregation ||\r\n      props.elevationAggregation !== oldProps.elevationAggregation\r\n    ) {\r\n      this._updateBinOptions();\r\n      const {radiusCommon, hexOriginCommon, binIdRange, dataAsArray} = this.state;\r\n\r\n      aggregator.setProps({\r\n        // @ts-expect-error only used by GPUAggregator\r\n        binIdRange,\r\n        pointCount: this.getNumInstances(),\r\n        operations: [props.colorAggregation, props.elevationAggregation],\r\n        binOptions: {\r\n          radiusCommon,\r\n          hexOriginCommon\r\n        },\r\n        onUpdate: this._onAggregationUpdate.bind(this)\r\n      });\r\n\r\n      if (dataAsArray) {\r\n        const {getColorValue, getElevationValue} = this.props;\r\n        aggregator.setProps({\r\n          // @ts-expect-error only used by CPUAggregator\r\n          customOperations: [\r\n            getColorValue &&\r\n              ((indices: number[]) =>\r\n                getColorValue(\r\n                  indices.map(i => dataAsArray[i]),\r\n                  {indices, data: props.data}\r\n                )),\r\n            getElevationValue &&\r\n              ((indices: number[]) =>\r\n                getElevationValue(\r\n                  indices.map(i => dataAsArray[i]),\r\n                  {indices, data: props.data}\r\n                ))\r\n          ]\r\n        });\r\n      }\r\n    }\r\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\r\n      aggregator.setNeedsUpdate(0);\r\n    }\r\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\r\n      aggregator.setNeedsUpdate(1);\r\n    }\r\n\r\n    return aggregatorChanged;\r\n  }\r\n\r\n  private _updateBinOptions() {\r\n    const bounds = this.getBounds();\r\n    let radiusCommon = 1;\r\n    let hexOriginCommon: [number, number] = [0, 0];\r\n    let binIdRange: [number, number][] = [\r\n      [0, 1],\r\n      [0, 1]\r\n    ];\r\n    let viewport = this.context.viewport;\r\n\r\n    if (bounds && Number.isFinite(bounds[0][0])) {\r\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\r\n      const {radius} = this.props;\r\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\r\n      radiusCommon = unitsPerMeter[0] * radius;\r\n\r\n      // Use the centroid of the hex at the center of the data\r\n      // This offsets the common space without changing the bins\r\n      const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);\r\n      centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));\r\n\r\n      const ViewportType = viewport.constructor as any;\r\n      // We construct a viewport for the GPU aggregator's project module\r\n      // This viewport is determined by data\r\n      // removes arbitrary precision variance that depends on initial view state\r\n      viewport = viewport.isGeospatial\r\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\r\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\r\n\r\n      hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\r\n\r\n      binIdRange = getBinIdRange({\r\n        dataBounds: bounds,\r\n        getBinId: (p: number[]) => {\r\n          const positionCommon = viewport.projectFlat(p);\r\n          positionCommon[0] -= hexOriginCommon[0];\r\n          positionCommon[1] -= hexOriginCommon[1];\r\n          return pointToHexbin(positionCommon, radiusCommon);\r\n        },\r\n        padding: 1\r\n      });\r\n    }\r\n\r\n    this.setState({radiusCommon, hexOriginCommon, binIdRange, aggregatorViewport: viewport});\r\n  }\r\n\r\n  override draw(opts) {\r\n    // Replaces render time viewport with our own\r\n    if (opts.shaderModuleProps.project) {\r\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\r\n    }\r\n    super.draw(opts);\r\n  }\r\n\r\n  private _onAggregationUpdate({channel}: {channel: number}) {\r\n    const props = this.getCurrentLayer()!.props;\r\n    const {aggregator} = this.state;\r\n    if (channel === 0) {\r\n      const result = aggregator.getResult(0)!;\r\n      this.setState({\r\n        colors: new AttributeWithScale(result, aggregator.binCount)\r\n      });\r\n      props.onSetColorDomain(aggregator.getResultDomain(0));\r\n    } else if (channel === 1) {\r\n      const result = aggregator.getResult(1)!;\r\n      this.setState({\r\n        elevations: new AttributeWithScale(result, aggregator.binCount)\r\n      });\r\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\r\n    }\r\n  }\r\n\r\n  onAttributeChange(id: string) {\r\n    const {aggregator} = this.state;\r\n    switch (id) {\r\n      case 'positions':\r\n        aggregator.setNeedsUpdate();\r\n\r\n        this._updateBinOptions();\r\n        const {radiusCommon, hexOriginCommon, binIdRange} = this.state;\r\n        aggregator.setProps({\r\n          // @ts-expect-error only used by GPUAggregator\r\n          binIdRange,\r\n          binOptions: {\r\n            radiusCommon,\r\n            hexOriginCommon\r\n          }\r\n        });\r\n        break;\r\n\r\n      case 'colorWeights':\r\n        aggregator.setNeedsUpdate(0);\r\n        break;\r\n\r\n      case 'elevationWeights':\r\n        aggregator.setNeedsUpdate(1);\r\n        break;\r\n\r\n      default:\r\n      // This should not happen\r\n    }\r\n  }\r\n\r\n  renderLayers(): LayersList | Layer | null {\r\n    const {aggregator, radiusCommon, hexOriginCommon} = this.state;\r\n    const {\r\n      elevationScale,\r\n      colorRange,\r\n      elevationRange,\r\n      extruded,\r\n      coverage,\r\n      material,\r\n      transitions,\r\n      colorScaleType,\r\n      lowerPercentile,\r\n      upperPercentile,\r\n      colorDomain,\r\n      elevationScaleType,\r\n      elevationLowerPercentile,\r\n      elevationUpperPercentile,\r\n      elevationDomain\r\n    } = this.props;\r\n    const CellLayerClass = this.getSubLayerClass('cells', HexagonCellLayer);\r\n    const binAttribute = aggregator.getBins();\r\n\r\n    const colors = this.state.colors?.update({\r\n      scaleType: colorScaleType,\r\n      lowerPercentile,\r\n      upperPercentile\r\n    });\r\n    const elevations = this.state.elevations?.update({\r\n      scaleType: elevationScaleType,\r\n      lowerPercentile: elevationLowerPercentile,\r\n      upperPercentile: elevationUpperPercentile\r\n    });\r\n\r\n    if (!colors || !elevations) {\r\n      return null;\r\n    }\r\n\r\n    return new CellLayerClass(\r\n      this.getSubLayerProps({\r\n        id: 'cells'\r\n      }),\r\n      {\r\n        data: {\r\n          length: aggregator.binCount,\r\n          attributes: {\r\n            getBin: binAttribute,\r\n            getColorValue: colors.attribute,\r\n            getElevationValue: elevations.attribute\r\n          }\r\n        },\r\n        // Data has changed shallowly, but we likely don't need to update the attributes\r\n        dataComparator: (data, oldData) => data.length === oldData.length,\r\n        updateTriggers: {\r\n          getBin: [binAttribute],\r\n          getColorValue: [colors.attribute],\r\n          getElevationValue: [elevations.attribute]\r\n        },\r\n        diskResolution: 6,\r\n        vertices: HexbinVertices,\r\n        radius: radiusCommon,\r\n        hexOriginCommon,\r\n        elevationScale,\r\n        colorRange,\r\n        colorScaleType,\r\n        elevationRange,\r\n        extruded,\r\n        coverage,\r\n        material,\r\n        colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\r\n        elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\r\n        colorCutoff: colors.cutoff,\r\n        elevationCutoff: elevations.cutoff,\r\n        transitions: transitions && {\r\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\r\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\r\n        },\r\n        // Extensions are already handled by the GPUAggregator, do not pass it down\r\n        extensions: []\r\n      }\r\n    );\r\n  }\r\n\r\n  getPickingInfo(params: GetPickingInfoParams): HexagonLayerPickingInfo<DataT> {\r\n    const info: HexagonLayerPickingInfo<DataT> = params.info;\r\n    const {index} = info;\r\n    if (index >= 0) {\r\n      const bin = this.state.aggregator.getBin(index);\r\n      let object: HexagonLayerPickingInfo<DataT>['object'];\r\n      if (bin) {\r\n        const centroidCommon = getHexbinCentroid(\r\n          bin.id as [number, number],\r\n          this.state.radiusCommon\r\n        );\r\n        const centroid = this.context.viewport.unprojectFlat(centroidCommon);\r\n\r\n        object = {\r\n          col: bin.id[0],\r\n          row: bin.id[1],\r\n          position: centroid,\r\n          colorValue: bin.value[0],\r\n          elevationValue: bin.value[1],\r\n          count: bin.count\r\n        };\r\n        if (bin.pointIndices) {\r\n          object.pointIndices = bin.pointIndices;\r\n          object.points = Array.isArray(this.props.data)\r\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\r\n            : [];\r\n        }\r\n      }\r\n      info.object = object;\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\n// Code to Offsets Map needed to implement Marching Squares algorithm\r\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\r\n\r\n// Table to map code to the intersection offsets\r\n// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)\r\nconst HALF = 0.5;\r\nconst ONE6TH = 1 / 6;\r\nconst OFFSET = {\r\n  N: [0, HALF], // NORTH\r\n  E: [HALF, 0], // EAST\r\n  S: [0, -HALF], // SOUTH\r\n  W: [-HALF, 0], // WEST\r\n\r\n  // CORNERS\r\n  NE: [HALF, HALF],\r\n  NW: [-HALF, HALF],\r\n  SE: [HALF, -HALF],\r\n  SW: [-HALF, -HALF]\r\n};\r\n\r\n// NOTE: vertices are ordered in CCW direction, starting from NW corner\r\n\r\n// Triangles\r\nconst SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];\r\nconst SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];\r\nconst NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];\r\nconst NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];\r\n\r\n// Trapezoids\r\nconst SW_TRAPEZOID = [\r\n  [-HALF, ONE6TH],\r\n  [-HALF, -ONE6TH],\r\n  [-ONE6TH, -HALF],\r\n  [ONE6TH, -HALF]\r\n];\r\nconst SE_TRAPEZOID = [\r\n  [-ONE6TH, -HALF],\r\n  [ONE6TH, -HALF],\r\n  [HALF, -ONE6TH],\r\n  [HALF, ONE6TH]\r\n];\r\nconst NE_TRAPEZOID = [\r\n  [HALF, -ONE6TH],\r\n  [HALF, ONE6TH],\r\n  [ONE6TH, HALF],\r\n  [-ONE6TH, HALF]\r\n];\r\nconst NW_TRAPEZOID = [\r\n  [-HALF, ONE6TH],\r\n  [-HALF, -ONE6TH],\r\n  [ONE6TH, HALF],\r\n  [-ONE6TH, HALF]\r\n];\r\n\r\n// Rectangles\r\nconst S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];\r\nconst E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\r\nconst N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];\r\nconst W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];\r\nconst EW_RECTANGEL = [\r\n  [-HALF, ONE6TH],\r\n  [-HALF, -ONE6TH],\r\n  [HALF, -ONE6TH],\r\n  [HALF, ONE6TH]\r\n];\r\nconst SN_RECTANGEL = [\r\n  [-ONE6TH, -HALF],\r\n  [ONE6TH, -HALF],\r\n  [ONE6TH, HALF],\r\n  [-ONE6TH, HALF]\r\n];\r\n\r\n// Square\r\nconst SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];\r\n\r\n// Pentagons\r\nconst SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];\r\nconst SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];\r\nconst NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];\r\nconst NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];\r\n\r\nconst NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\r\nconst NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];\r\nconst SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];\r\nconst SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];\r\n\r\nconst NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];\r\nconst NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];\r\nconst SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\r\nconst SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];\r\n\r\n// Hexagon\r\nconst S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\r\nconst E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\r\nconst N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];\r\nconst W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\r\nconst SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];\r\nconst NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];\r\n\r\n// Heptagon (7-sided)\r\nconst NE_HEPTAGON = [\r\n  [-HALF, ONE6TH],\r\n  [-HALF, -ONE6TH],\r\n  [-ONE6TH, -HALF],\r\n  [ONE6TH, -HALF],\r\n  OFFSET.E,\r\n  OFFSET.NE,\r\n  OFFSET.N\r\n];\r\nconst SW_HEPTAGON = [\r\n  OFFSET.W,\r\n  OFFSET.SW,\r\n  OFFSET.S,\r\n  [HALF, -ONE6TH],\r\n  [HALF, ONE6TH],\r\n  [ONE6TH, HALF],\r\n  [-ONE6TH, HALF]\r\n];\r\nconst NW_HEPTAGON = [\r\n  OFFSET.NW,\r\n  OFFSET.W,\r\n  [-ONE6TH, -HALF],\r\n  [ONE6TH, -HALF],\r\n  [HALF, -ONE6TH],\r\n  [HALF, ONE6TH],\r\n  OFFSET.N\r\n];\r\nconst SE_HEPTAGON = [\r\n  [-HALF, ONE6TH],\r\n  [-HALF, -ONE6TH],\r\n  OFFSET.S,\r\n  OFFSET.SE,\r\n  OFFSET.E,\r\n  [ONE6TH, HALF],\r\n  [-ONE6TH, HALF]\r\n];\r\n\r\n// Octagon\r\nconst OCTAGON = [\r\n  [-HALF, ONE6TH],\r\n  [-HALF, -ONE6TH],\r\n  [-ONE6TH, -HALF],\r\n  [ONE6TH, -HALF],\r\n  [HALF, -ONE6TH],\r\n  [HALF, ONE6TH],\r\n  [ONE6TH, HALF],\r\n  [-ONE6TH, HALF]\r\n];\r\n\r\n// Note: above wiki page invertes white/black dots for generating the code, we don't\r\nexport const ISOLINES_CODE_OFFSET_MAP = {\r\n  // key is equal to the code of 4 vertices (invert the code specified in wiki)\r\n  // value can be an array or an Object\r\n  // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]\r\n  // Object : to handle saddle cases, whos output depends on mean value of all 4 corners\r\n  //  key: code of mean value (0 or 1)\r\n  //  value: Array , as above defines one or two line segments\r\n  0: [],\r\n  1: [[OFFSET.W, OFFSET.S]],\r\n  2: [[OFFSET.S, OFFSET.E]],\r\n  3: [[OFFSET.W, OFFSET.E]],\r\n  4: [[OFFSET.N, OFFSET.E]],\r\n  5: {\r\n    0: [\r\n      [OFFSET.W, OFFSET.S],\r\n      [OFFSET.N, OFFSET.E]\r\n    ],\r\n    1: [\r\n      [OFFSET.W, OFFSET.N],\r\n      [OFFSET.S, OFFSET.E]\r\n    ]\r\n  },\r\n  6: [[OFFSET.N, OFFSET.S]],\r\n  7: [[OFFSET.W, OFFSET.N]],\r\n  8: [[OFFSET.W, OFFSET.N]],\r\n  9: [[OFFSET.N, OFFSET.S]],\r\n  10: {\r\n    0: [\r\n      [OFFSET.W, OFFSET.N],\r\n      [OFFSET.S, OFFSET.E]\r\n    ],\r\n    1: [\r\n      [OFFSET.W, OFFSET.S],\r\n      [OFFSET.N, OFFSET.E]\r\n    ]\r\n  },\r\n  11: [[OFFSET.N, OFFSET.E]],\r\n  12: [[OFFSET.W, OFFSET.E]],\r\n  13: [[OFFSET.S, OFFSET.E]],\r\n  14: [[OFFSET.W, OFFSET.S]],\r\n  15: []\r\n};\r\n\r\nfunction ternaryToIndex(ternary) {\r\n  return parseInt(ternary, 4);\r\n}\r\n\r\nexport const ISOBANDS_CODE_OFFSET_MAP = {\r\n  // Below list of cases, follow the same order as in above mentioned wiki page.\r\n  // Each case has its code on first commented line // T,TR,R,C\r\n  // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2\r\n  // final code is binary representation of above code , where takes 2 digits\r\n  // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169\r\n\r\n  // no contours\r\n  [ternaryToIndex('0000')]: [],\r\n  [ternaryToIndex('2222')]: [],\r\n\r\n  // single triangle\r\n  [ternaryToIndex('2221')]: [SW_TRIANGLE],\r\n  [ternaryToIndex('2212')]: [SE_TRIANGLE],\r\n  [ternaryToIndex('2122')]: [NE_TRIANGLE],\r\n  [ternaryToIndex('1222')]: [NW_TRIANGLE],\r\n  [ternaryToIndex('0001')]: [SW_TRIANGLE],\r\n  [ternaryToIndex('0010')]: [SE_TRIANGLE],\r\n  [ternaryToIndex('0100')]: [NE_TRIANGLE],\r\n  [ternaryToIndex('1000')]: [NW_TRIANGLE],\r\n\r\n  // single trapezoid\r\n  [ternaryToIndex('2220')]: [SW_TRAPEZOID],\r\n  [ternaryToIndex('2202')]: [SE_TRAPEZOID],\r\n  [ternaryToIndex('2022')]: [NE_TRAPEZOID],\r\n  [ternaryToIndex('0222')]: [NW_TRAPEZOID],\r\n  [ternaryToIndex('0002')]: [SW_TRAPEZOID],\r\n  [ternaryToIndex('0020')]: [SE_TRAPEZOID],\r\n  [ternaryToIndex('0200')]: [NE_TRAPEZOID],\r\n  [ternaryToIndex('2000')]: [NW_TRAPEZOID],\r\n\r\n  // single rectangle\r\n  [ternaryToIndex('0011')]: [S_RECTANGLE],\r\n  [ternaryToIndex('0110')]: [E_RECTANGLE],\r\n  [ternaryToIndex('1100')]: [N_RECTANGLE],\r\n  [ternaryToIndex('1001')]: [W_RECTANGLE],\r\n  [ternaryToIndex('2211')]: [S_RECTANGLE],\r\n  [ternaryToIndex('2112')]: [E_RECTANGLE],\r\n  [ternaryToIndex('1122')]: [N_RECTANGLE],\r\n  [ternaryToIndex('1221')]: [W_RECTANGLE],\r\n  [ternaryToIndex('2200')]: [EW_RECTANGEL],\r\n  [ternaryToIndex('2002')]: [SN_RECTANGEL],\r\n  [ternaryToIndex('0022')]: [EW_RECTANGEL],\r\n  [ternaryToIndex('0220')]: [SN_RECTANGEL],\r\n\r\n  // single square\r\n  // 1111\r\n  [ternaryToIndex('1111')]: [SQUARE],\r\n\r\n  // single pentagon\r\n  [ternaryToIndex('1211')]: [SW_PENTAGON],\r\n  [ternaryToIndex('2111')]: [SE_PENTAGON],\r\n  [ternaryToIndex('1112')]: [NE_PENTAGON],\r\n  [ternaryToIndex('1121')]: [NW_PENTAGON],\r\n  [ternaryToIndex('1011')]: [SW_PENTAGON],\r\n  [ternaryToIndex('0111')]: [SE_PENTAGON],\r\n  [ternaryToIndex('1110')]: [NE_PENTAGON],\r\n  [ternaryToIndex('1101')]: [NW_PENTAGON],\r\n  [ternaryToIndex('1200')]: [NW_N_PENTAGON],\r\n  [ternaryToIndex('0120')]: [NE_E_PENTAGON],\r\n  [ternaryToIndex('0012')]: [SE_S_PENTAGON],\r\n  [ternaryToIndex('2001')]: [SW_W_PENTAGON],\r\n  [ternaryToIndex('1022')]: [NW_N_PENTAGON],\r\n  [ternaryToIndex('2102')]: [NE_E_PENTAGON],\r\n  [ternaryToIndex('2210')]: [SE_S_PENTAGON],\r\n  [ternaryToIndex('0221')]: [SW_W_PENTAGON],\r\n  [ternaryToIndex('1002')]: [NW_W_PENTAGON],\r\n  [ternaryToIndex('2100')]: [NE_N_PENTAGON],\r\n  [ternaryToIndex('0210')]: [SE_E_PENTAGON],\r\n  [ternaryToIndex('0021')]: [SW_S_PENTAGON],\r\n  [ternaryToIndex('1220')]: [NW_W_PENTAGON],\r\n  [ternaryToIndex('0122')]: [NE_N_PENTAGON],\r\n  [ternaryToIndex('2012')]: [SE_E_PENTAGON],\r\n  [ternaryToIndex('2201')]: [SW_S_PENTAGON],\r\n\r\n  // single hexagon\r\n  [ternaryToIndex('0211')]: [S_HEXAGON],\r\n  [ternaryToIndex('2110')]: [E_HEXAGON],\r\n  [ternaryToIndex('1102')]: [N_HEXAGON],\r\n  [ternaryToIndex('1021')]: [W_HEXAGON],\r\n  [ternaryToIndex('2011')]: [S_HEXAGON],\r\n  [ternaryToIndex('0112')]: [E_HEXAGON],\r\n  [ternaryToIndex('1120')]: [N_HEXAGON],\r\n  [ternaryToIndex('1201')]: [W_HEXAGON],\r\n  [ternaryToIndex('2101')]: [SW_NE_HEXAGON],\r\n  [ternaryToIndex('0121')]: [SW_NE_HEXAGON],\r\n  [ternaryToIndex('1012')]: [NW_SE_HEXAGON],\r\n  [ternaryToIndex('1210')]: [NW_SE_HEXAGON],\r\n\r\n  // 6-sided polygons based on mean weight\r\n  // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)\r\n  [ternaryToIndex('0101')]: {\r\n    0: [SW_TRIANGLE, NE_TRIANGLE],\r\n    1: [SW_NE_HEXAGON],\r\n    2: [SW_NE_HEXAGON]\r\n  },\r\n  [ternaryToIndex('1010')]: {\r\n    0: [NW_TRIANGLE, SE_TRIANGLE],\r\n    1: [NW_SE_HEXAGON],\r\n    2: [NW_SE_HEXAGON]\r\n  },\r\n  [ternaryToIndex('2121')]: {\r\n    0: [SW_NE_HEXAGON],\r\n    1: [SW_NE_HEXAGON],\r\n    2: [SW_TRIANGLE, NE_TRIANGLE]\r\n  },\r\n  [ternaryToIndex('1212')]: {\r\n    0: [NW_SE_HEXAGON],\r\n    1: [NW_SE_HEXAGON],\r\n    2: [NW_TRIANGLE, SE_TRIANGLE]\r\n  },\r\n\r\n  // 7-sided polygons based on mean weight\r\n  [ternaryToIndex('2120')]: {\r\n    0: [NE_HEPTAGON],\r\n    1: [NE_HEPTAGON],\r\n    2: [SW_TRAPEZOID, NE_TRIANGLE]\r\n  },\r\n  [ternaryToIndex('2021')]: {\r\n    0: [SW_HEPTAGON],\r\n    1: [SW_HEPTAGON],\r\n    2: [SW_TRIANGLE, NE_TRAPEZOID]\r\n  },\r\n  [ternaryToIndex('1202')]: {\r\n    0: [NW_HEPTAGON],\r\n    1: [NW_HEPTAGON],\r\n    2: [NW_TRIANGLE, SE_TRAPEZOID]\r\n  },\r\n  [ternaryToIndex('0212')]: {\r\n    0: [SE_HEPTAGON],\r\n    1: [SE_HEPTAGON],\r\n    2: [SE_TRIANGLE, NW_TRAPEZOID]\r\n  },\r\n  [ternaryToIndex('0102')]: {\r\n    0: [SW_TRAPEZOID, NE_TRIANGLE],\r\n    1: [NE_HEPTAGON],\r\n    2: [NE_HEPTAGON]\r\n  },\r\n  [ternaryToIndex('0201')]: {\r\n    0: [SW_TRIANGLE, NE_TRAPEZOID],\r\n    1: [SW_HEPTAGON],\r\n    2: [SW_HEPTAGON]\r\n  },\r\n  [ternaryToIndex('1020')]: {\r\n    0: [NW_TRIANGLE, SE_TRAPEZOID],\r\n    1: [NW_HEPTAGON],\r\n    2: [NW_HEPTAGON]\r\n  },\r\n  [ternaryToIndex('2010')]: {\r\n    0: [SE_TRIANGLE, NW_TRAPEZOID],\r\n    1: [SE_HEPTAGON],\r\n    2: [SE_HEPTAGON]\r\n  },\r\n\r\n  // 8-sided polygons based on mean weight\r\n  [ternaryToIndex('2020')]: {\r\n    0: [NW_TRAPEZOID, SE_TRAPEZOID],\r\n    1: [OCTAGON],\r\n    2: [SW_TRAPEZOID, NE_TRAPEZOID]\r\n  },\r\n  [ternaryToIndex('0202')]: {\r\n    0: [NE_TRAPEZOID, SW_TRAPEZOID],\r\n    1: [OCTAGON],\r\n    2: [NW_TRAPEZOID, SE_TRAPEZOID]\r\n  }\r\n};\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\n// All utility methods needed to implement Marching Squares algorithm\r\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\r\n\r\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\r\n\r\n// Utility methods\r\n\r\nfunction getVertexCode(weight: number, threshold: number | number[]): number {\r\n  // threshold must be a single value or a range (array of size 2)\r\n  if (Number.isNaN(weight)) {\r\n    return 0;\r\n  }\r\n  // Iso-bands\r\n  if (Array.isArray(threshold)) {\r\n    if (weight < threshold[0]) {\r\n      return 0;\r\n    }\r\n    return weight < threshold[1] ? 1 : 2;\r\n  }\r\n  // Iso-lines\r\n  return weight >= threshold ? 1 : 0;\r\n}\r\n\r\n// Returns marching square code for given cell\r\n/* eslint-disable complexity, max-statements*/\r\nexport function getCode(opts: {\r\n  getValue: (x: number, y: number) => number;\r\n  threshold: number | number[];\r\n  x: number;\r\n  xRange: [number, number];\r\n  y: number;\r\n  yRange: [number, number];\r\n}): {\r\n  code: number;\r\n  meanCode: number;\r\n} {\r\n  // Assumptions\r\n  // Origin is on bottom-left , and X increase to right, Y to top\r\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\r\n  // to create a 2X2 cell grid\r\n  const {x, y, xRange, yRange, getValue, threshold} = opts;\r\n\r\n  const isLeftBoundary = x < xRange[0];\r\n  const isRightBoundary = x >= xRange[1] - 1;\r\n  const isBottomBoundary = y < yRange[0];\r\n  const isTopBoundary = y >= yRange[1] - 1;\r\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\r\n\r\n  let weights: number = 0;\r\n  let current: number;\r\n  let right: number;\r\n  let top: number;\r\n  let topRight: number;\r\n\r\n  // TOP\r\n  if (isLeftBoundary || isTopBoundary) {\r\n    top = 0;\r\n  } else {\r\n    const w = getValue(x, y + 1);\r\n    top = getVertexCode(w, threshold);\r\n    weights += w;\r\n  }\r\n\r\n  // TOP-RIGHT\r\n  if (isRightBoundary || isTopBoundary) {\r\n    topRight = 0;\r\n  } else {\r\n    const w = getValue(x + 1, y + 1);\r\n    topRight = getVertexCode(w, threshold);\r\n    weights += w;\r\n  }\r\n\r\n  // RIGHT\r\n  if (isRightBoundary || isBottomBoundary) {\r\n    right = 0;\r\n  } else {\r\n    const w = getValue(x + 1, y);\r\n    right = getVertexCode(w, threshold);\r\n    weights += w;\r\n  }\r\n\r\n  // CURRENT\r\n  if (isLeftBoundary || isBottomBoundary) {\r\n    current = 0;\r\n  } else {\r\n    const w = getValue(x, y);\r\n    current = getVertexCode(w, threshold);\r\n    weights += w;\r\n  }\r\n\r\n  let code = -1;\r\n  if (Number.isFinite(threshold)) {\r\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\r\n  }\r\n  if (Array.isArray(threshold)) {\r\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\r\n  }\r\n\r\n  let meanCode = 0;\r\n  // meanCode is only needed for saddle cases, and they should\r\n  // only occur when we are not processing a cell on boundary\r\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\r\n  if (!isBoundary) {\r\n    meanCode = getVertexCode(weights / 4, threshold);\r\n  }\r\n  return {code, meanCode};\r\n}\r\n/* eslint-enable complexity, max-statements*/\r\n\r\n// Returns intersection vertices for given cellindex\r\n// [x, y] refers current marching cell, reference vertex is always top-right corner\r\nexport function getPolygons(opts: {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n  code: number;\r\n  meanCode: number;\r\n}) {\r\n  const {x, y, z, code, meanCode} = opts;\r\n  let offsets: any = ISOBANDS_CODE_OFFSET_MAP[code];\r\n\r\n  // handle saddle cases\r\n  if (!Array.isArray(offsets)) {\r\n    offsets = offsets[meanCode];\r\n  }\r\n\r\n  // Reference vertex is at top-right move to top-right corner\r\n  const rX = x + 1;\r\n  const rY = y + 1;\r\n\r\n  // offsets format\r\n  // [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\r\n  // vertices format\r\n  // [\r\n  //   [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\r\n  //        ...\r\n  // ]\r\n\r\n  const polygons: number[][][] = [];\r\n  offsets.forEach(polygonOffsets => {\r\n    const polygon: number[][] = [];\r\n    polygonOffsets.forEach(xyOffset => {\r\n      const vX = rX + xyOffset[0];\r\n      const vY = rY + xyOffset[1];\r\n      polygon.push([vX, vY, z]);\r\n    });\r\n    polygons.push(polygon);\r\n  });\r\n  return polygons;\r\n}\r\n\r\n// Returns intersection vertices for given cellindex\r\n// [x, y] refers current marching cell, reference vertex is always top-right corner\r\nexport function getLines(opts: {x: number; y: number; z: number; code: number; meanCode: number}) {\r\n  const {x, y, z, code, meanCode} = opts;\r\n  let offsets = ISOLINES_CODE_OFFSET_MAP[code];\r\n\r\n  // handle saddle cases\r\n  if (!Array.isArray(offsets)) {\r\n    offsets = offsets[meanCode];\r\n  }\r\n\r\n  // Reference vertex is at top-right move to top-right corner\r\n  const rX = x + 1;\r\n  const rY = y + 1;\r\n\r\n  // offsets format\r\n  // [[1A, 1B], [2A, 2B]],\r\n  // vertices format\r\n  // [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\r\n  const lines: number[][] = [];\r\n  offsets.forEach(xyOffsets => {\r\n    xyOffsets.forEach(offset => {\r\n      const vX = rX + offset[0];\r\n      const vY = rY + offset[1];\r\n      lines.push([vX, vY, z]);\r\n    });\r\n  });\r\n  return lines;\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Color} from '@deck.gl/core';\r\nimport {getCode, getLines, getPolygons} from './marching-squares';\r\n\r\nexport type Contour = {\r\n  /**\r\n   * Isolines: `threshold` value must be a single `Number`, Isolines are generated based on this threshold value.\r\n   *\r\n   * Isobands: `threshold` value must be an Array of two `Number`s. Isobands are generated using `[threshold[0], threshold[1])` as threshold range, i.e area that has values `>= threshold[0]` and `< threshold[1]` are rendered with corresponding color. NOTE: `threshold[0]` is inclusive and `threshold[1]` is not inclusive.\r\n   */\r\n  threshold: number | number[];\r\n\r\n  /**\r\n   * RGBA color array to be used to render the contour.\r\n   * @default [255, 255, 255, 255]\r\n   */\r\n  color?: Color;\r\n\r\n  /**\r\n   * Applicable for `Isoline`s only, width of the Isoline in pixels.\r\n   * @default 1\r\n   */\r\n  strokeWidth?: number;\r\n\r\n  /** Defines z order of the contour. */\r\n  zIndex?: number;\r\n};\r\n\r\nexport type ContourLine = {\r\n  vertices: number[][];\r\n  contour: Contour;\r\n};\r\n\r\nexport type ContourPolygon = {\r\n  vertices: number[][];\r\n  contour: Contour;\r\n};\r\n\r\n// Given all the cell weights, generates contours for each threshold.\r\n/* eslint-disable max-depth */\r\nexport function generateContours({\r\n  contours,\r\n  getValue,\r\n  xRange,\r\n  yRange\r\n}: {\r\n  contours: Contour[];\r\n  getValue: (x: number, y: number) => number;\r\n  xRange: [number, number];\r\n  yRange: [number, number];\r\n}) {\r\n  const contourLines: ContourLine[] = [];\r\n  const contourPolygons: ContourPolygon[] = [];\r\n  let segmentIndex = 0;\r\n  let polygonIndex = 0;\r\n\r\n  for (let i = 0; i < contours.length; i++) {\r\n    const contour = contours[i];\r\n    const z = contour.zIndex ?? i;\r\n    const {threshold} = contour;\r\n    for (let x = xRange[0] - 1; x < xRange[1]; x++) {\r\n      for (let y = yRange[0] - 1; y < yRange[1]; y++) {\r\n        // Get the MarchingSquares code based on neighbor cell weights.\r\n        const {code, meanCode} = getCode({\r\n          getValue,\r\n          threshold,\r\n          x,\r\n          y,\r\n          xRange,\r\n          yRange\r\n        });\r\n        const opts = {\r\n          x,\r\n          y,\r\n          z,\r\n          code,\r\n          meanCode\r\n        };\r\n        if (Array.isArray(threshold)) {\r\n          // ISO bands\r\n          const polygons = getPolygons(opts);\r\n          for (const polygon of polygons) {\r\n            contourPolygons[polygonIndex++] = {\r\n              vertices: polygon,\r\n              contour\r\n            };\r\n          }\r\n        } else {\r\n          // ISO lines\r\n          const path = getLines(opts);\r\n          if (path.length > 0) {\r\n            contourLines[segmentIndex++] = {\r\n              vertices: path,\r\n              contour\r\n            };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return {lines: contourLines, polygons: contourPolygons};\r\n}\r\n/* eslint-enable max-depth */\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Aggregator, CPUAggregator, WebGLAggregator} from '../common/aggregator/index';\r\nimport type {TypedArray} from '@luma.gl/core';\r\n\r\ntype ValueReader = (x: number, y: number) => number;\r\n\r\n/** Returns an accessor to the aggregated values from bin id */\r\nexport function getAggregatorValueReader(opts: {\r\n  aggregator: Aggregator;\r\n  binIdRange: [number, number][];\r\n  channel: 0 | 1 | 2;\r\n}): ValueReader | null {\r\n  const {aggregator, binIdRange, channel} = opts;\r\n\r\n  if (aggregator instanceof WebGLAggregator) {\r\n    const buffer = aggregator.getResult(channel)?.buffer;\r\n    if (buffer) {\r\n      const values = new Float32Array(buffer.readSyncWebGL().buffer);\r\n      return getWebGLAggregatorValueReader(values, binIdRange);\r\n    }\r\n  }\r\n  if (aggregator instanceof CPUAggregator) {\r\n    const values = aggregator.getResult(channel)?.value;\r\n    const ids = aggregator.getBins()?.value;\r\n    if (ids && values) {\r\n      return getCPUAggregatorValueReader(values, ids, aggregator.binCount);\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction getWebGLAggregatorValueReader(\r\n  values: Float32Array,\r\n  binIdRange: [number, number][]\r\n): ValueReader {\r\n  const [[minX, maxX], [minY, maxY]] = binIdRange;\r\n  const width = maxX - minX;\r\n  const height = maxY - minY;\r\n  return (x: number, y: number) => {\r\n    x -= minX;\r\n    y -= minY;\r\n    if (x < 0 || x >= width || y < 0 || y >= height) {\r\n      return NaN;\r\n    }\r\n    return values[y * width + x];\r\n  };\r\n}\r\n\r\nfunction getCPUAggregatorValueReader(\r\n  values: TypedArray,\r\n  ids: TypedArray,\r\n  count: number\r\n): ValueReader {\r\n  const idMap: Record<string, Record<string, number>> = {};\r\n  for (let i = 0; i < count; i++) {\r\n    const x = ids[i * 2];\r\n    const y = ids[i * 2 + 1];\r\n    idMap[x] = idMap[x] || {};\r\n    idMap[x][y] = values[i];\r\n  }\r\n  return (x: number, y: number) => idMap[x]?.[y] ?? NaN;\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform binOptionsUniforms {\r\n  vec2 cellOriginCommon;\r\n  vec2 cellSizeCommon;\r\n} binOptions;\r\n`;\r\n\r\nexport type BinOptions = {\r\n  cellOriginCommon: [number, number];\r\n  cellSizeCommon: [number, number];\r\n};\r\n\r\nexport const binOptionsUniforms = {\r\n  name: 'binOptions',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    cellOriginCommon: 'vec2<f32>',\r\n    cellSizeCommon: 'vec2<f32>'\r\n  }\r\n} as const satisfies ShaderModule<BinOptions>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {\r\n  Accessor,\r\n  COORDINATE_SYSTEM,\r\n  GetPickingInfoParams,\r\n  project32,\r\n  LayersList,\r\n  PickingInfo,\r\n  Position,\r\n  Viewport,\r\n  _deepEqual,\r\n  UpdateParameters,\r\n  DefaultProps\r\n} from '@deck.gl/core';\r\nimport {PathLayer, SolidPolygonLayer} from '@deck.gl/layers';\r\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\r\nimport AggregationLayer from '../common/aggregation-layer';\r\nimport {AggregationLayerProps} from '../common/aggregation-layer';\r\nimport {generateContours, Contour, ContourLine, ContourPolygon} from './contour-utils';\r\nimport {getAggregatorValueReader} from './value-reader';\r\nimport {getBinIdRange} from '../common/utils/bounds-utils';\r\nimport {Matrix4} from '@math.gl/core';\r\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\r\n\r\nconst DEFAULT_COLOR = [255, 255, 255, 255];\r\nconst DEFAULT_STROKE_WIDTH = 1;\r\n\r\nconst defaultProps: DefaultProps<ContourLayerProps> = {\r\n  // grid aggregation\r\n  cellSize: {type: 'number', min: 1, value: 1000},\r\n  gridOrigin: {type: 'array', compare: true, value: [0, 0]},\r\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\r\n  getWeight: {type: 'accessor', value: 1},\r\n  gpuAggregation: true,\r\n  aggregation: 'SUM',\r\n\r\n  // contour lines\r\n  contours: {\r\n    type: 'object',\r\n    value: [{threshold: 1}],\r\n    optional: true,\r\n    compare: 3\r\n  },\r\n\r\n  zOffset: 0.005\r\n};\r\n\r\n/** All properties supported by GridLayer. */\r\nexport type ContourLayerProps<DataT = unknown> = _ContourLayerProps<DataT> &\r\n  AggregationLayerProps<DataT>;\r\n\r\n/** Properties added by GridLayer. */\r\ntype _ContourLayerProps<DataT> = {\r\n  /**\r\n   * Size of each cell in meters.\r\n   * @default 1000\r\n   */\r\n  cellSize?: number;\r\n\r\n  /**\r\n   * The grid origin\r\n   * @default [0, 0]\r\n   */\r\n  gridOrigin?: [number, number];\r\n\r\n  /**\r\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\r\n   * @default false\r\n   */\r\n  gpuAggregation?: boolean;\r\n\r\n  /**\r\n   * Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\r\n   * @default 'SUM'\r\n   */\r\n  aggregation?: AggregationOperation;\r\n\r\n  /**\r\n   * Definition of contours to be drawn.\r\n   * @default [{threshold: 1}]\r\n   */\r\n  contours?: Contour[];\r\n\r\n  /**\r\n   * A very small z offset that is added for each vertex of a contour (Isoline or Isoband).\r\n   * @default 0.005\r\n   */\r\n  zOffset?: number;\r\n\r\n  /**\r\n   * Method called to retrieve the position of each object.\r\n   * @default object => object.position\r\n   */\r\n  getPosition?: Accessor<DataT, Position>;\r\n\r\n  /**\r\n   * The weight of each object.\r\n   * @default 1\r\n   */\r\n  getWeight?: Accessor<DataT, number>;\r\n};\r\n\r\nexport type ContourLayerPickingInfo = PickingInfo<{\r\n  contour: Contour;\r\n}>;\r\n\r\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\r\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends AggregationLayer<\r\n  DataT,\r\n  ExtraPropsT & Required<_ContourLayerProps<DataT>>\r\n> {\r\n  static layerName = 'ContourLayer';\r\n  static defaultProps = defaultProps;\r\n\r\n  state!: AggregationLayer<DataT>['state'] &\r\n    BinOptions & {\r\n      // Aggregator result\r\n      aggregatedValueReader?: (x: number, y: number) => number;\r\n      contourData?: {\r\n        lines: ContourLine[];\r\n        polygons: ContourPolygon[];\r\n      };\r\n\r\n      binIdRange: [number, number][];\r\n      aggregatorViewport: Viewport;\r\n    };\r\n\r\n  getAggregatorType(): string {\r\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\r\n      ? 'gpu'\r\n      : 'cpu';\r\n  }\r\n\r\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\r\n    if (type === 'cpu') {\r\n      return new CPUAggregator({\r\n        dimensions: 2,\r\n        getBin: {\r\n          sources: ['positions'],\r\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\r\n            const viewport = this.state.aggregatorViewport;\r\n            // project to common space\r\n            const p = viewport.projectPosition(positions);\r\n            const {cellSizeCommon, cellOriginCommon} = opts;\r\n            return [\r\n              Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\r\n              Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\r\n            ];\r\n          }\r\n        },\r\n        getValue: [{sources: ['counts'], getValue: ({counts}) => counts}],\r\n        onUpdate: this._onAggregationUpdate.bind(this)\r\n      });\r\n    }\r\n    return new WebGLAggregator(this.context.device, {\r\n      dimensions: 2,\r\n      channelCount: 1,\r\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\r\n      ...super.getShaders({\r\n        modules: [project32, binOptionsUniforms],\r\n        vs: /* glsl */ `\r\n  in vec3 positions;\r\n  in vec3 positions64Low;\r\n  in float counts;\r\n\r\n  void getBin(out ivec2 binId) {\r\n    vec3 positionCommon = project_position(positions, positions64Low);\r\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\r\n    binId = ivec2(gridCoords);\r\n  }\r\n  void getValue(out float value) {\r\n    value = counts;\r\n  }\r\n  `\r\n      }),\r\n      onUpdate: this._onAggregationUpdate.bind(this)\r\n    });\r\n  }\r\n\r\n  initializeState() {\r\n    super.initializeState();\r\n\r\n    const attributeManager = this.getAttributeManager()!;\r\n    attributeManager.add({\r\n      positions: {\r\n        size: 3,\r\n        accessor: 'getPosition',\r\n        type: 'float64',\r\n        fp64: this.use64bitPositions()\r\n      },\r\n      counts: {size: 1, accessor: 'getWeight'}\r\n    });\r\n  }\r\n\r\n  updateState(params: UpdateParameters<this>) {\r\n    const aggregatorChanged = super.updateState(params);\r\n\r\n    const {props, oldProps, changeFlags} = params;\r\n    const {aggregator} = this.state;\r\n    if (\r\n      aggregatorChanged ||\r\n      changeFlags.dataChanged ||\r\n      props.cellSize !== oldProps.cellSize ||\r\n      !_deepEqual(props.gridOrigin, oldProps.gridOrigin, 1) ||\r\n      props.aggregation !== oldProps.aggregation\r\n    ) {\r\n      this._updateBinOptions();\r\n      const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\r\n\r\n      aggregator.setProps({\r\n        // @ts-expect-error only used by GPUAggregator\r\n        binIdRange,\r\n        pointCount: this.getNumInstances(),\r\n        operations: [props.aggregation],\r\n        binOptions: {\r\n          cellSizeCommon,\r\n          cellOriginCommon\r\n        }\r\n      });\r\n    }\r\n\r\n    if (!_deepEqual(oldProps.contours, props.contours, 2)) {\r\n      // Recalculate contours\r\n      this.setState({contourData: null});\r\n    }\r\n\r\n    return aggregatorChanged;\r\n  }\r\n\r\n  private _updateBinOptions() {\r\n    const bounds = this.getBounds();\r\n    const cellSizeCommon: [number, number] = [1, 1];\r\n    let cellOriginCommon: [number, number] = [0, 0];\r\n    let binIdRange: [number, number][] = [\r\n      [0, 1],\r\n      [0, 1]\r\n    ];\r\n    let viewport = this.context.viewport;\r\n\r\n    if (bounds && Number.isFinite(bounds[0][0])) {\r\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\r\n      const {cellSize, gridOrigin} = this.props;\r\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\r\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\r\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\r\n\r\n      // Offset common space to center at the origin of the grid cell where the data center is in\r\n      // This improves precision without affecting the cell positions\r\n      const centroidCommon = viewport.projectFlat(centroid);\r\n      cellOriginCommon = [\r\n        Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] +\r\n          gridOrigin[0],\r\n        Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] +\r\n          gridOrigin[1]\r\n      ];\r\n      centroid = viewport.unprojectFlat(cellOriginCommon);\r\n\r\n      const ViewportType = viewport.constructor as any;\r\n      // We construct a viewport for the GPU aggregator's project module\r\n      // This viewport is determined by data\r\n      // removes arbitrary precision variance that depends on initial view state\r\n      viewport = viewport.isGeospatial\r\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\r\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\r\n\r\n      // Round to the nearest 32-bit float to match CPU and GPU results\r\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\r\n\r\n      binIdRange = getBinIdRange({\r\n        dataBounds: bounds,\r\n        getBinId: (p: number[]) => {\r\n          const positionCommon = viewport.projectFlat(p);\r\n          return [\r\n            Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\r\n            Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\r\n          ];\r\n        }\r\n      });\r\n    }\r\n\r\n    this.setState({cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport});\r\n  }\r\n\r\n  override draw(opts) {\r\n    // Replaces render time viewport with our own\r\n    if (opts.shaderModuleProps.project) {\r\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\r\n    }\r\n    super.draw(opts);\r\n  }\r\n\r\n  private _onAggregationUpdate() {\r\n    const {aggregator, binIdRange} = this.state;\r\n    this.setState({\r\n      aggregatedValueReader: getAggregatorValueReader({aggregator, binIdRange, channel: 0}),\r\n      contourData: null\r\n    });\r\n  }\r\n\r\n  private _getContours(): {\r\n    lines: ContourLine[];\r\n    polygons: ContourPolygon[];\r\n  } | null {\r\n    const {aggregatedValueReader} = this.state;\r\n    if (!aggregatedValueReader) {\r\n      return null;\r\n    }\r\n\r\n    if (!this.state.contourData) {\r\n      const {binIdRange} = this.state;\r\n      const {contours} = this.props;\r\n      const contourData = generateContours({\r\n        contours,\r\n        getValue: aggregatedValueReader,\r\n        xRange: binIdRange[0],\r\n        yRange: binIdRange[1]\r\n      });\r\n\r\n      this.state.contourData = contourData;\r\n    }\r\n    return this.state.contourData;\r\n  }\r\n\r\n  onAttributeChange(id: string) {\r\n    const {aggregator} = this.state;\r\n    switch (id) {\r\n      case 'positions':\r\n        aggregator.setNeedsUpdate();\r\n\r\n        this._updateBinOptions();\r\n        const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\r\n        aggregator.setProps({\r\n          // @ts-expect-error only used by GPUAggregator\r\n          binIdRange,\r\n          binOptions: {\r\n            cellSizeCommon,\r\n            cellOriginCommon\r\n          }\r\n        });\r\n        break;\r\n\r\n      case 'counts':\r\n        aggregator.setNeedsUpdate(0);\r\n        break;\r\n\r\n      default:\r\n      // This should not happen\r\n    }\r\n  }\r\n\r\n  renderLayers(): LayersList | null {\r\n    const contourData = this._getContours();\r\n    if (!contourData) {\r\n      return null;\r\n    }\r\n    const {lines, polygons} = contourData;\r\n    const {zOffset} = this.props;\r\n    const {cellOriginCommon, cellSizeCommon} = this.state;\r\n\r\n    const LinesSubLayerClass = this.getSubLayerClass('lines', PathLayer);\r\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\r\n    const modelMatrix = new Matrix4()\r\n      .translate([cellOriginCommon[0], cellOriginCommon[1], 0])\r\n      .scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);\r\n\r\n    // Contour lines layer\r\n    const lineLayer =\r\n      lines &&\r\n      lines.length > 0 &&\r\n      new LinesSubLayerClass(\r\n        this.getSubLayerProps({\r\n          id: 'lines'\r\n        }),\r\n        {\r\n          data: lines,\r\n          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\r\n          modelMatrix,\r\n          getPath: d => d.vertices,\r\n          getColor: d => d.contour.color ?? DEFAULT_COLOR,\r\n          getWidth: d => d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,\r\n          widthUnits: 'pixels'\r\n        }\r\n      );\r\n\r\n    // Contour bands layer\r\n    const bandsLayer =\r\n      polygons &&\r\n      polygons.length > 0 &&\r\n      new BandsSubLayerClass(\r\n        this.getSubLayerProps({\r\n          id: 'bands'\r\n        }),\r\n        {\r\n          data: polygons,\r\n          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\r\n          modelMatrix,\r\n          getPolygon: d => d.vertices,\r\n          getFillColor: d => d.contour.color ?? DEFAULT_COLOR\r\n        }\r\n      );\r\n\r\n    return [lineLayer, bandsLayer];\r\n  }\r\n\r\n  getPickingInfo(params: GetPickingInfoParams): ContourLayerPickingInfo {\r\n    const info: ContourLayerPickingInfo = params.info;\r\n    const {object} = info;\r\n    if (object) {\r\n      info.object = {\r\n        contour: (object as ContourLine | ContourPolygon).contour\r\n      };\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport default /* glsl */ `#version 300 es\r\n\r\n#define SHADER_NAME grid-cell-layer-vertex-shader\r\n\r\nin vec3 positions;\r\nin vec3 normals;\r\n\r\nin vec2 instancePositions;\r\nin float instanceElevationValues;\r\nin float instanceColorValues;\r\nin vec3 instancePickingColors;\r\n\r\nuniform sampler2D colorRange;\r\n\r\n// Result\r\nout vec4 vColor;\r\n\r\nfloat interp(float value, vec2 domain, vec2 range) {\r\n  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\r\n  return mix(range.x, range.y, r);\r\n}\r\n\r\nvec4 interp(float value, vec2 domain, sampler2D range) {\r\n  float r = (value - domain.x) / (domain.y - domain.x);\r\n  return texture(range, vec2(r, 0.5));\r\n}\r\n\r\nvoid main(void) {\r\n  geometry.pickingColor = instancePickingColors;\r\n\r\n  if (isnan(instanceColorValues) ||\r\n    instanceColorValues < grid.colorDomain.z ||\r\n    instanceColorValues > grid.colorDomain.w ||\r\n    instanceElevationValues < grid.elevationDomain.z ||\r\n    instanceElevationValues > grid.elevationDomain.w\r\n  ) {\r\n    gl_Position = vec4(0.);\r\n    return;\r\n  }\r\n  \r\n  vec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;\r\n  geometry.position = vec4(commonPosition, 0.0, 1.0);\r\n  geometry.normal = project_normal(normals);\r\n\r\n  // calculate z, if 3d not enabled set to 0\r\n  float elevation = 0.0;\r\n  if (column.extruded) {\r\n    elevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);\r\n    elevation = project_size(elevation);\r\n    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\r\n    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\r\n  }\r\n\r\n  gl_Position = project_common_position_to_clipspace(geometry.position);\r\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\r\n\r\n  vColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);\r\n  vColor.a *= layer.opacity;\r\n  if (column.extruded) {\r\n    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\r\n  }\r\n  DECKGL_FILTER_COLOR(vColor, geometry);\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform gridUniforms {\r\n  vec4 colorDomain;\r\n  vec4 elevationDomain;\r\n  vec2 elevationRange;\r\n  vec2 originCommon;\r\n  vec2 sizeCommon;\r\n} grid;\r\n`;\r\n\r\nexport type GridProps = {\r\n  colorDomain: [number, number, number, number];\r\n  colorRange: Texture;\r\n  elevationDomain: [number, number, number, number];\r\n  elevationRange: [number, number];\r\n  originCommon: [number, number];\r\n  sizeCommon: [number, number];\r\n};\r\n\r\nexport const gridUniforms = {\r\n  name: 'grid',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    colorDomain: 'vec4<f32>',\r\n    elevationDomain: 'vec4<f32>',\r\n    elevationRange: 'vec2<f32>',\r\n    originCommon: 'vec2<f32>',\r\n    sizeCommon: 'vec2<f32>'\r\n  }\r\n} as const satisfies ShaderModule<GridProps>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport {UpdateParameters, Color} from '@deck.gl/core';\r\nimport {ColumnLayer} from '@deck.gl/layers';\r\nimport {CubeGeometry} from '@luma.gl/engine';\r\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\r\nimport vs from './grid-cell-layer-vertex.glsl';\r\nimport {GridProps, gridUniforms} from './grid-layer-uniforms';\r\nimport type {ScaleType} from '../common/types';\r\n\r\n/** Proprties added by GridCellLayer. */\r\ntype GridCellLayerProps = {\r\n  cellSizeCommon: [number, number];\r\n  cellOriginCommon: [number, number];\r\n  colorDomain: [number, number];\r\n  colorCutoff: [number, number] | null;\r\n  colorRange: Color[];\r\n  colorScaleType: ScaleType;\r\n  elevationDomain: [number, number];\r\n  elevationCutoff: [number, number] | null;\r\n  elevationRange: [number, number];\r\n};\r\n\r\nexport class GridCellLayer<ExtraPropsT extends {} = {}> extends ColumnLayer<\r\n  null,\r\n  ExtraPropsT & Required<GridCellLayerProps>\r\n> {\r\n  static layerName = 'GridCellLayer';\r\n\r\n  state!: ColumnLayer['state'] & {\r\n    colorTexture: Texture;\r\n  };\r\n\r\n  getShaders() {\r\n    const shaders = super.getShaders();\r\n    shaders.modules.push(gridUniforms);\r\n    return {...shaders, vs};\r\n  }\r\n\r\n  initializeState() {\r\n    super.initializeState();\r\n\r\n    const attributeManager = this.getAttributeManager()!;\r\n    attributeManager.remove([\r\n      'instanceElevations',\r\n      'instanceFillColors',\r\n      'instanceLineColors',\r\n      'instanceStrokeWidths'\r\n    ]);\r\n    attributeManager.addInstanced({\r\n      instancePositions: {\r\n        size: 2,\r\n        type: 'float32',\r\n        accessor: 'getBin'\r\n      },\r\n      instanceColorValues: {\r\n        size: 1,\r\n        type: 'float32',\r\n        accessor: 'getColorValue'\r\n      },\r\n      instanceElevationValues: {\r\n        size: 1,\r\n        type: 'float32',\r\n        accessor: 'getElevationValue'\r\n      }\r\n    });\r\n  }\r\n\r\n  updateState(params: UpdateParameters<this>) {\r\n    super.updateState(params);\r\n\r\n    const {props, oldProps} = params;\r\n    const model = this.state.fillModel!;\r\n\r\n    if (oldProps.colorRange !== props.colorRange) {\r\n      this.state.colorTexture?.destroy();\r\n      this.state.colorTexture = createColorRangeTexture(\r\n        this.context.device,\r\n        props.colorRange,\r\n        props.colorScaleType\r\n      );\r\n      const gridProps: Partial<GridProps> = {colorRange: this.state.colorTexture};\r\n      model.shaderInputs.setProps({grid: gridProps});\r\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\r\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\r\n    }\r\n  }\r\n\r\n  finalizeState(context) {\r\n    super.finalizeState(context);\r\n\r\n    this.state.colorTexture?.destroy();\r\n  }\r\n\r\n  protected _updateGeometry() {\r\n    const geometry = new CubeGeometry();\r\n    this.state.fillModel!.setGeometry(geometry);\r\n  }\r\n\r\n  draw({uniforms}) {\r\n    const {\r\n      cellOriginCommon,\r\n      cellSizeCommon,\r\n      elevationRange,\r\n      elevationScale,\r\n      extruded,\r\n      coverage,\r\n      colorDomain,\r\n      elevationDomain\r\n    } = this.props;\r\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\r\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\r\n    const fillModel = this.state.fillModel!;\r\n\r\n    const gridProps: Omit<GridProps, 'colorRange'> = {\r\n      colorDomain: [\r\n        Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\r\n        Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\r\n        Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\r\n        Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\r\n      ],\r\n      elevationDomain: [\r\n        Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\r\n        Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\r\n        Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\r\n        Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\r\n      ],\r\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\r\n      originCommon: cellOriginCommon,\r\n      sizeCommon: cellSizeCommon\r\n    };\r\n    fillModel.shaderInputs.setProps({\r\n      column: {extruded, coverage},\r\n      grid: gridProps\r\n    });\r\n    fillModel.draw(this.context.renderPass);\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = /* glsl */ `\\\r\nuniform binOptionsUniforms {\r\n  vec2 cellOriginCommon;\r\n  vec2 cellSizeCommon;\r\n} binOptions;\r\n`;\r\n\r\nexport type BinOptions = {\r\n  cellOriginCommon: [number, number];\r\n  cellSizeCommon: [number, number];\r\n};\r\n\r\nexport const binOptionsUniforms = {\r\n  name: 'binOptions',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    cellOriginCommon: 'vec2<f32>',\r\n    cellSizeCommon: 'vec2<f32>'\r\n  }\r\n} as const satisfies ShaderModule<BinOptions>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {\r\n  log,\r\n  Accessor,\r\n  Color,\r\n  GetPickingInfoParams,\r\n  CompositeLayerProps,\r\n  createIterable,\r\n  Layer,\r\n  Material,\r\n  project32,\r\n  LayersList,\r\n  PickingInfo,\r\n  Position,\r\n  Viewport,\r\n  UpdateParameters,\r\n  DefaultProps\r\n} from '@deck.gl/core';\r\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\r\nimport AggregationLayer from '../common/aggregation-layer';\r\nimport {AggregateAccessor} from '../common/types';\r\nimport {defaultColorRange} from '../common/utils/color-utils';\r\nimport {AttributeWithScale} from '../common/utils/scale-utils';\r\nimport {getBinIdRange} from '../common/utils/bounds-utils';\r\n\r\nimport {GridCellLayer} from './grid-cell-layer';\r\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-function\r\nfunction noop() {}\r\n\r\nconst defaultProps: DefaultProps<GridLayerProps> = {\r\n  gpuAggregation: true,\r\n\r\n  // color\r\n  colorDomain: null,\r\n  colorRange: defaultColorRange,\r\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\r\n  getColorWeight: {type: 'accessor', value: 1},\r\n  colorAggregation: 'SUM',\r\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\r\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\r\n  colorScaleType: 'quantize',\r\n  onSetColorDomain: noop,\r\n\r\n  // elevation\r\n  elevationDomain: null,\r\n  elevationRange: [0, 1000],\r\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\r\n  getElevationWeight: {type: 'accessor', value: 1},\r\n  elevationAggregation: 'SUM',\r\n  elevationScale: {type: 'number', min: 0, value: 1},\r\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\r\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\r\n  elevationScaleType: 'linear',\r\n  onSetElevationDomain: noop,\r\n\r\n  // grid\r\n  cellSize: {type: 'number', min: 0, value: 1000},\r\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\r\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\r\n  gridAggregator: {type: 'function', optional: true, value: null},\r\n  extruded: false,\r\n\r\n  // Optional material for 'lighting' shader module\r\n  material: true\r\n};\r\n\r\n/** All properties supported by GridLayer. */\r\nexport type GridLayerProps<DataT = unknown> = _GridLayerProps<DataT> & CompositeLayerProps;\r\n\r\n/** Properties added by GridLayer. */\r\ntype _GridLayerProps<DataT> = {\r\n  /**\r\n   * Custom accessor to retrieve a grid bin index from each data object.\r\n   * Not supported by GPU aggregation.\r\n   */\r\n  gridAggregator?: ((position: number[], cellSize: number) => [number, number]) | null;\r\n\r\n  /**\r\n   * Size of each cell in meters.\r\n   * @default 1000\r\n   */\r\n  cellSize?: number;\r\n\r\n  /**\r\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\r\n   * @default [min(colorWeight), max(colorWeight)]\r\n   */\r\n  colorDomain?: [number, number] | null;\r\n\r\n  /**\r\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\r\n   */\r\n  colorRange?: Color[];\r\n\r\n  /**\r\n   * Cell size multiplier, clamped between 0 - 1.\r\n   * @default 1\r\n   */\r\n  coverage?: number;\r\n\r\n  /**\r\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\r\n   * @default [0, max(elevationWeight)]\r\n   */\r\n  elevationDomain?: [number, number] | null;\r\n\r\n  /**\r\n   * Elevation scale output range.\r\n   * @default [0, 1000]\r\n   */\r\n  elevationRange?: [number, number];\r\n\r\n  /**\r\n   * Cell elevation multiplier.\r\n   * @default 1\r\n   */\r\n  elevationScale?: number;\r\n\r\n  /**\r\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\r\n   * @default true\r\n   */\r\n  extruded?: boolean;\r\n\r\n  /**\r\n   * Filter cells and re-calculate color by `upperPercentile`.\r\n   * Cells with value larger than the upperPercentile will be hidden.\r\n   * @default 100\r\n   */\r\n  upperPercentile?: number;\r\n\r\n  /**\r\n   * Filter cells and re-calculate color by `lowerPercentile`.\r\n   * Cells with value smaller than the lowerPercentile will be hidden.\r\n   * @default 0\r\n   */\r\n  lowerPercentile?: number;\r\n\r\n  /**\r\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\r\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\r\n   * @default 100\r\n   */\r\n  elevationUpperPercentile?: number;\r\n\r\n  /**\r\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\r\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\r\n   * @default 0\r\n   */\r\n  elevationLowerPercentile?: number;\r\n\r\n  /**\r\n   * Scaling function used to determine the color of the grid cell.\r\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\r\n   * @default 'quantize'\r\n   */\r\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\r\n\r\n  /**\r\n   * Scaling function used to determine the elevation of the grid cell.\r\n   * Supported Values are 'linear' and 'quantile'.\r\n   * @default 'linear'\r\n   */\r\n  elevationScaleType?: 'linear' | 'quantile';\r\n\r\n  /**\r\n   * Material settings for lighting effect. Applies if `extruded: true`.\r\n   *\r\n   * @default true\r\n   * @see https://deck.gl/docs/developer-guide/using-lighting\r\n   */\r\n  material?: Material;\r\n\r\n  /**\r\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\r\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\r\n   *\r\n   * @default 'SUM'\r\n   */\r\n  colorAggregation?: AggregationOperation;\r\n\r\n  /**\r\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\r\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\r\n   *\r\n   * @default 'SUM'\r\n   */\r\n  elevationAggregation?: AggregationOperation;\r\n\r\n  /**\r\n   * Method called to retrieve the position of each object.\r\n   * @default object => object.position\r\n   */\r\n  getPosition?: Accessor<DataT, Position>;\r\n\r\n  /**\r\n   * The weight of a data object used to calculate the color value for a cell.\r\n   * @default 1\r\n   */\r\n  getColorWeight?: Accessor<DataT, number>;\r\n\r\n  /**\r\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\r\n   * Not supported by GPU aggregation.\r\n   * @default null\r\n   */\r\n  getColorValue?: AggregateAccessor<DataT> | null;\r\n\r\n  /**\r\n   * The weight of a data object used to calculate the elevation value for a cell.\r\n   * @default 1\r\n   */\r\n  getElevationWeight?: Accessor<DataT, number>;\r\n\r\n  /**\r\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\r\n   * Not supported by GPU aggregation.\r\n   * @default null\r\n   */\r\n  getElevationValue?: AggregateAccessor<DataT> | null;\r\n\r\n  /**\r\n   * This callback will be called when bin color domain has been calculated.\r\n   * @default () => {}\r\n   */\r\n  onSetColorDomain?: (minMax: [number, number]) => void;\r\n\r\n  /**\r\n   * This callback will be called when bin elevation domain has been calculated.\r\n   * @default () => {}\r\n   */\r\n  onSetElevationDomain?: (minMax: [number, number]) => void;\r\n\r\n  /**\r\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\r\n   * @default true\r\n   */\r\n  gpuAggregation?: boolean;\r\n};\r\n\r\nexport type GridLayerPickingInfo<DataT> = PickingInfo<{\r\n  /** Column index of the picked cell */\r\n  col: number;\r\n  /** Row index of the picked cell */\r\n  row: number;\r\n  /** Aggregated color value, as determined by `getColorWeight` and `colorAggregation` */\r\n  colorValue: number;\r\n  /** Aggregated elevation value, as determined by `getElevationWeight` and `elevationAggregation` */\r\n  elevationValue: number;\r\n  /** Number of data points in the picked cell */\r\n  count: number;\r\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\r\n  pointIndices?: number[];\r\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\r\n  points?: DataT[];\r\n}>;\r\n\r\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\r\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends AggregationLayer<\r\n  DataT,\r\n  ExtraPropsT & Required<_GridLayerProps<DataT>>\r\n> {\r\n  static layerName = 'GridLayer';\r\n  static defaultProps = defaultProps;\r\n\r\n  state!: AggregationLayer<DataT>['state'] &\r\n    BinOptions & {\r\n      // Needed if getColorValue, getElevationValue are used\r\n      dataAsArray?: DataT[];\r\n\r\n      colors?: AttributeWithScale;\r\n      elevations?: AttributeWithScale;\r\n\r\n      binIdRange: [number, number][];\r\n      aggregatorViewport: Viewport;\r\n    };\r\n\r\n  getAggregatorType(): string {\r\n    const {gpuAggregation, gridAggregator, getColorValue, getElevationValue} = this.props;\r\n    if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {\r\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\r\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\r\n      return 'cpu';\r\n    }\r\n\r\n    if (\r\n      // GPU aggregation is requested\r\n      gpuAggregation &&\r\n      // GPU aggregation is supported by the device\r\n      WebGLAggregator.isSupported(this.context.device)\r\n    ) {\r\n      return 'gpu';\r\n    }\r\n    return 'cpu';\r\n  }\r\n\r\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\r\n    if (type === 'cpu') {\r\n      const {gridAggregator, cellSize} = this.props;\r\n      return new CPUAggregator({\r\n        dimensions: 2,\r\n        getBin: {\r\n          sources: ['positions'],\r\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\r\n            if (gridAggregator) {\r\n              return gridAggregator(positions, cellSize);\r\n            }\r\n            const viewport = this.state.aggregatorViewport;\r\n            // project to common space\r\n            const p = viewport.projectPosition(positions);\r\n            const {cellSizeCommon, cellOriginCommon} = opts;\r\n            return [\r\n              Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\r\n              Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\r\n            ];\r\n          }\r\n        },\r\n        getValue: [\r\n          {sources: ['colorWeights'], getValue: ({colorWeights}) => colorWeights},\r\n          {sources: ['elevationWeights'], getValue: ({elevationWeights}) => elevationWeights}\r\n        ]\r\n      });\r\n    }\r\n    return new WebGLAggregator(this.context.device, {\r\n      dimensions: 2,\r\n      channelCount: 2,\r\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\r\n      ...super.getShaders({\r\n        modules: [project32, binOptionsUniforms],\r\n        vs: /* glsl */ `\r\n  in vec3 positions;\r\n  in vec3 positions64Low;\r\n  in float colorWeights;\r\n  in float elevationWeights;\r\n\r\n  void getBin(out ivec2 binId) {\r\n    vec3 positionCommon = project_position(positions, positions64Low);\r\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\r\n    binId = ivec2(gridCoords);\r\n  }\r\n  void getValue(out vec2 value) {\r\n    value = vec2(colorWeights, elevationWeights);\r\n  }\r\n  `\r\n      })\r\n    });\r\n  }\r\n\r\n  initializeState() {\r\n    super.initializeState();\r\n\r\n    const attributeManager = this.getAttributeManager()!;\r\n    attributeManager.add({\r\n      positions: {\r\n        size: 3,\r\n        accessor: 'getPosition',\r\n        type: 'float64',\r\n        fp64: this.use64bitPositions()\r\n      },\r\n      colorWeights: {size: 1, accessor: 'getColorWeight'},\r\n      elevationWeights: {size: 1, accessor: 'getElevationWeight'}\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line complexity\r\n  updateState(params: UpdateParameters<this>) {\r\n    const aggregatorChanged = super.updateState(params);\r\n\r\n    const {props, oldProps, changeFlags} = params;\r\n    const {aggregator} = this.state;\r\n    if (\r\n      (changeFlags.dataChanged || !this.state.dataAsArray) &&\r\n      (props.getColorValue || props.getElevationValue)\r\n    ) {\r\n      // Convert data to array\r\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\r\n    }\r\n    if (\r\n      aggregatorChanged ||\r\n      changeFlags.dataChanged ||\r\n      props.cellSize !== oldProps.cellSize ||\r\n      props.getColorValue !== oldProps.getColorValue ||\r\n      props.getElevationValue !== oldProps.getElevationValue ||\r\n      props.colorAggregation !== oldProps.colorAggregation ||\r\n      props.elevationAggregation !== oldProps.elevationAggregation\r\n    ) {\r\n      this._updateBinOptions();\r\n      const {cellSizeCommon, cellOriginCommon, binIdRange, dataAsArray} = this.state;\r\n\r\n      aggregator.setProps({\r\n        // @ts-expect-error only used by GPUAggregator\r\n        binIdRange,\r\n        pointCount: this.getNumInstances(),\r\n        operations: [props.colorAggregation, props.elevationAggregation],\r\n        binOptions: {\r\n          cellSizeCommon,\r\n          cellOriginCommon\r\n        },\r\n        onUpdate: this._onAggregationUpdate.bind(this)\r\n      });\r\n\r\n      if (dataAsArray) {\r\n        const {getColorValue, getElevationValue} = this.props;\r\n        aggregator.setProps({\r\n          // @ts-expect-error only used by CPUAggregator\r\n          customOperations: [\r\n            getColorValue &&\r\n              ((indices: number[]) =>\r\n                getColorValue(\r\n                  indices.map(i => dataAsArray[i]),\r\n                  {indices, data: props.data}\r\n                )),\r\n            getElevationValue &&\r\n              ((indices: number[]) =>\r\n                getElevationValue(\r\n                  indices.map(i => dataAsArray[i]),\r\n                  {indices, data: props.data}\r\n                ))\r\n          ]\r\n        });\r\n      }\r\n    }\r\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\r\n      aggregator.setNeedsUpdate(0);\r\n    }\r\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\r\n      aggregator.setNeedsUpdate(1);\r\n    }\r\n\r\n    return aggregatorChanged;\r\n  }\r\n\r\n  private _updateBinOptions() {\r\n    const bounds = this.getBounds();\r\n    const cellSizeCommon: [number, number] = [1, 1];\r\n    let cellOriginCommon: [number, number] = [0, 0];\r\n    let binIdRange: [number, number][] = [\r\n      [0, 1],\r\n      [0, 1]\r\n    ];\r\n    let viewport = this.context.viewport;\r\n\r\n    if (bounds && Number.isFinite(bounds[0][0])) {\r\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\r\n      const {cellSize} = this.props;\r\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\r\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\r\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\r\n\r\n      // Offset common space to center at the origin of the grid cell where the data center is in\r\n      // This improves precision without affecting the cell positions\r\n      const centroidCommon = viewport.projectFlat(centroid);\r\n      cellOriginCommon = [\r\n        Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0],\r\n        Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]\r\n      ];\r\n      centroid = viewport.unprojectFlat(cellOriginCommon);\r\n\r\n      const ViewportType = viewport.constructor as any;\r\n      // We construct a viewport for the GPU aggregator's project module\r\n      // This viewport is determined by data\r\n      // removes arbitrary precision variance that depends on initial view state\r\n      viewport = viewport.isGeospatial\r\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\r\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\r\n\r\n      // Round to the nearest 32-bit float to match CPU and GPU results\r\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\r\n\r\n      binIdRange = getBinIdRange({\r\n        dataBounds: bounds,\r\n        getBinId: (p: number[]) => {\r\n          const positionCommon = viewport.projectFlat(p);\r\n          return [\r\n            Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\r\n            Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\r\n          ];\r\n        }\r\n      });\r\n    }\r\n\r\n    this.setState({cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport});\r\n  }\r\n\r\n  override draw(opts) {\r\n    // Replaces render time viewport with our own\r\n    if (opts.shaderModuleProps.project) {\r\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\r\n    }\r\n    super.draw(opts);\r\n  }\r\n\r\n  private _onAggregationUpdate({channel}: {channel: number}) {\r\n    const props = this.getCurrentLayer()!.props;\r\n    const {aggregator} = this.state;\r\n    if (channel === 0) {\r\n      const result = aggregator.getResult(0)!;\r\n      this.setState({\r\n        colors: new AttributeWithScale(result, aggregator.binCount)\r\n      });\r\n      props.onSetColorDomain(aggregator.getResultDomain(0));\r\n    } else if (channel === 1) {\r\n      const result = aggregator.getResult(1)!;\r\n      this.setState({\r\n        elevations: new AttributeWithScale(result, aggregator.binCount)\r\n      });\r\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\r\n    }\r\n  }\r\n\r\n  onAttributeChange(id: string) {\r\n    const {aggregator} = this.state;\r\n    switch (id) {\r\n      case 'positions':\r\n        aggregator.setNeedsUpdate();\r\n\r\n        this._updateBinOptions();\r\n        const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\r\n        aggregator.setProps({\r\n          // @ts-expect-error only used by GPUAggregator\r\n          binIdRange,\r\n          binOptions: {\r\n            cellSizeCommon,\r\n            cellOriginCommon\r\n          }\r\n        });\r\n        break;\r\n\r\n      case 'colorWeights':\r\n        aggregator.setNeedsUpdate(0);\r\n        break;\r\n\r\n      case 'elevationWeights':\r\n        aggregator.setNeedsUpdate(1);\r\n        break;\r\n\r\n      default:\r\n      // This should not happen\r\n    }\r\n  }\r\n\r\n  renderLayers(): LayersList | Layer | null {\r\n    const {aggregator, cellOriginCommon, cellSizeCommon} = this.state;\r\n    const {\r\n      elevationScale,\r\n      colorRange,\r\n      elevationRange,\r\n      extruded,\r\n      coverage,\r\n      material,\r\n      transitions,\r\n      colorScaleType,\r\n      lowerPercentile,\r\n      upperPercentile,\r\n      colorDomain,\r\n      elevationScaleType,\r\n      elevationLowerPercentile,\r\n      elevationUpperPercentile,\r\n      elevationDomain\r\n    } = this.props;\r\n    const CellLayerClass = this.getSubLayerClass('cells', GridCellLayer);\r\n    const binAttribute = aggregator.getBins();\r\n\r\n    const colors = this.state.colors?.update({\r\n      scaleType: colorScaleType,\r\n      lowerPercentile,\r\n      upperPercentile\r\n    });\r\n    const elevations = this.state.elevations?.update({\r\n      scaleType: elevationScaleType,\r\n      lowerPercentile: elevationLowerPercentile,\r\n      upperPercentile: elevationUpperPercentile\r\n    });\r\n\r\n    if (!colors || !elevations) {\r\n      return null;\r\n    }\r\n\r\n    return new CellLayerClass(\r\n      this.getSubLayerProps({\r\n        id: 'cells'\r\n      }),\r\n      {\r\n        data: {\r\n          length: aggregator.binCount,\r\n          attributes: {\r\n            getBin: binAttribute,\r\n            getColorValue: colors.attribute,\r\n            getElevationValue: elevations.attribute\r\n          }\r\n        },\r\n        // Data has changed shallowly, but we likely don't need to update the attributes\r\n        dataComparator: (data, oldData) => data.length === oldData.length,\r\n        updateTriggers: {\r\n          getBin: [binAttribute],\r\n          getColorValue: [colors.attribute],\r\n          getElevationValue: [elevations.attribute]\r\n        },\r\n        cellOriginCommon,\r\n        cellSizeCommon,\r\n        elevationScale,\r\n        colorRange,\r\n        colorScaleType,\r\n        elevationRange,\r\n        extruded,\r\n        coverage,\r\n        material,\r\n        colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\r\n        elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\r\n        colorCutoff: colors.cutoff,\r\n        elevationCutoff: elevations.cutoff,\r\n        transitions: transitions && {\r\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\r\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\r\n        },\r\n        // Extensions are already handled by the GPUAggregator, do not pass it down\r\n        extensions: []\r\n      }\r\n    );\r\n  }\r\n\r\n  getPickingInfo(params: GetPickingInfoParams): GridLayerPickingInfo<DataT> {\r\n    const info: GridLayerPickingInfo<DataT> = params.info;\r\n    const {index} = info;\r\n    if (index >= 0) {\r\n      const bin = this.state.aggregator.getBin(index);\r\n      let object: GridLayerPickingInfo<DataT>['object'];\r\n      if (bin) {\r\n        object = {\r\n          col: bin.id[0],\r\n          row: bin.id[1],\r\n          colorValue: bin.value[0],\r\n          elevationValue: bin.value[1],\r\n          count: bin.count\r\n        };\r\n        if (bin.pointIndices) {\r\n          object.pointIndices = bin.pointIndices;\r\n          object.points = Array.isArray(this.props.data)\r\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\r\n            : [];\r\n        }\r\n      }\r\n      info.object = object;\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport function getBounds(points: number[][]): number[] {\r\n  // Now build bounding box in world space (aligned to world coordiante system)\r\n  const x = points.map(p => p[0]);\r\n  const y = points.map(p => p[1]);\r\n\r\n  const xMin = Math.min.apply(null, x);\r\n  const xMax = Math.max.apply(null, x);\r\n  const yMin = Math.min.apply(null, y);\r\n  const yMax = Math.max.apply(null, y);\r\n\r\n  return [xMin, yMin, xMax, yMax];\r\n}\r\n\r\n// true if currentBounds contains targetBounds, false otherwise\r\nexport function boundsContain(currentBounds: number[], targetBounds: number[]): boolean {\r\n  if (\r\n    targetBounds[0] >= currentBounds[0] &&\r\n    targetBounds[2] <= currentBounds[2] &&\r\n    targetBounds[1] >= currentBounds[1] &&\r\n    targetBounds[3] <= currentBounds[3]\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nconst scratchArray = new Float32Array(12);\r\n\r\n// For given rectangle bounds generates two triangles vertices that coverit completely\r\nexport function packVertices(points: number[][], dimensions: number = 2): Float32Array {\r\n  let index = 0;\r\n  for (const point of points) {\r\n    for (let i = 0; i < dimensions; i++) {\r\n      scratchArray[index++] = point[i] || 0;\r\n    }\r\n  }\r\n  return scratchArray;\r\n}\r\n\r\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\r\nexport function scaleToAspectRatio(\r\n  boundingBox: [number, number, number, number],\r\n  width: number,\r\n  height: number\r\n): [number, number, number, number] {\r\n  const [xMin, yMin, xMax, yMax] = boundingBox;\r\n\r\n  const currentWidth = xMax - xMin;\r\n  const currentHeight = yMax - yMin;\r\n\r\n  let newWidth = currentWidth;\r\n  let newHeight = currentHeight;\r\n  if (currentWidth / currentHeight < width / height) {\r\n    // expand bounding box width\r\n    newWidth = (width / height) * currentHeight;\r\n  } else {\r\n    newHeight = (height / width) * currentWidth;\r\n  }\r\n\r\n  if (newWidth < width) {\r\n    newWidth = width;\r\n    newHeight = height;\r\n  }\r\n\r\n  const xCenter = (xMax + xMin) / 2;\r\n  const yCenter = (yMax + yMin) / 2;\r\n\r\n  return [\r\n    xCenter - newWidth / 2,\r\n    yCenter - newHeight / 2,\r\n    xCenter + newWidth / 2,\r\n    yCenter + newHeight / 2\r\n  ];\r\n}\r\n\r\n// Get texture coordiante of point inside a bounding box\r\nexport function getTextureCoordinates(point: number[], bounds: number[]) {\r\n  const [xMin, yMin, xMax, yMax] = bounds;\r\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\n// Inspired by screen-grid-layer vertex shader in deck.gl\r\n\r\nexport default `\\\r\n#version 300 es\r\n#define SHADER_NAME heatp-map-layer-vertex-shader\r\n\r\nuniform sampler2D maxTexture;\r\n\r\nin vec3 positions;\r\nin vec2 texCoords;\r\n\r\nout vec2 vTexCoords;\r\nout float vIntensityMin;\r\nout float vIntensityMax;\r\n\r\nvoid main(void) {\r\n  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\r\n  vTexCoords = texCoords;\r\n  vec4 maxTexture = texture(maxTexture, vec2(0.5));\r\n  float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\r\n  float minValue = maxValue * triangle.threshold;\r\n  if (triangle.colorDomain[1] > 0.) {\r\n    // if user specified custom domain use it.\r\n    maxValue = triangle.colorDomain[1];\r\n    minValue = triangle.colorDomain[0];\r\n  }\r\n  vIntensityMax = triangle.intensity / maxValue;\r\n  vIntensityMin = triangle.intensity / minValue;\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport default `\\\r\n#version 300 es\r\n#define SHADER_NAME triangle-layer-fragment-shader\r\n\r\nprecision highp float;\r\n\r\nuniform sampler2D weightsTexture;\r\nuniform sampler2D colorTexture;\r\n\r\nin vec2 vTexCoords;\r\nin float vIntensityMin;\r\nin float vIntensityMax;\r\n\r\nout vec4 fragColor;\r\n\r\nvec4 getLinearColor(float value) {\r\n  float factor = clamp(value * vIntensityMax, 0., 1.);\r\n  vec4 color = texture(colorTexture, vec2(factor, 0.5));\r\n  color.a *= min(value * vIntensityMin, 1.0);\r\n  return color;\r\n}\r\n\r\nvoid main(void) {\r\n  vec4 weights = texture(weightsTexture, vTexCoords);\r\n  float weight = weights.r;\r\n\r\n  if (triangle.aggregationMode > 0.5) {\r\n    weight /= max(1.0, weights.a);\r\n  }\r\n\r\n  // discard pixels with 0 weight.\r\n  if (weight <= 0.) {\r\n     discard;\r\n  }\r\n\r\n  vec4 linearColor = getLinearColor(weight);\r\n  linearColor.a *= layer.opacity;\r\n  fragColor = linearColor;\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = `\\\r\nuniform triangleUniforms {\r\n  float aggregationMode;\r\n  vec2 colorDomain;\r\n  float intensity;\r\n  float threshold;\r\n} triangle;\r\n`;\r\n\r\nexport type TriangleProps = {\r\n  aggregationMode: number;\r\n  colorDomain: [number, number];\r\n  intensity: number;\r\n  threshold: number;\r\n  colorTexture: Texture;\r\n  maxTexture: Texture;\r\n  weightsTexture: Texture;\r\n};\r\n\r\nexport const triangleUniforms = {\r\n  name: 'triangle',\r\n  vs: uniformBlock,\r\n  fs: uniformBlock,\r\n  uniformTypes: {\r\n    aggregationMode: 'f32',\r\n    colorDomain: 'vec2<f32>',\r\n    intensity: 'f32',\r\n    threshold: 'f32'\r\n  }\r\n} as const satisfies ShaderModule<TriangleProps>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport type {Buffer, Device, Texture} from '@luma.gl/core';\r\nimport {Model} from '@luma.gl/engine';\r\nimport {Layer, LayerContext, project32} from '@deck.gl/core';\r\nimport vs from './triangle-layer-vertex.glsl';\r\nimport fs from './triangle-layer-fragment.glsl';\r\nimport {TriangleProps, triangleUniforms} from './triangle-layer-uniforms';\r\n\r\ntype _TriangleLayerProps = {\r\n  data: {attributes: {positions: Buffer; texCoords: Buffer}};\r\n  colorDomain: [number, number];\r\n  aggregationMode: number;\r\n  threshold: number;\r\n  intensity: number;\r\n  vertexCount: number;\r\n  colorTexture: Texture;\r\n  maxTexture: Texture;\r\n  weightsTexture: Texture;\r\n};\r\n\r\nexport default class TriangleLayer extends Layer<_TriangleLayerProps> {\r\n  static layerName = 'TriangleLayer';\r\n\r\n  state!: {\r\n    model: Model;\r\n    positions: Buffer;\r\n    texCoords: Buffer;\r\n  };\r\n\r\n  getShaders() {\r\n    return super.getShaders({vs, fs, modules: [project32, triangleUniforms]});\r\n  }\r\n\r\n  initializeState({device}: LayerContext): void {\r\n    this.setState({model: this._getModel(device)});\r\n  }\r\n\r\n  _getModel(device: Device): Model {\r\n    const {vertexCount, data} = this.props;\r\n\r\n    return new Model(device, {\r\n      ...this.getShaders(),\r\n      id: this.props.id,\r\n      attributes: data.attributes,\r\n      bufferLayout: [\r\n        {name: 'positions', format: 'float32x3'},\r\n        {name: 'texCoords', format: 'float32x2'}\r\n      ],\r\n      topology: 'triangle-strip',\r\n      vertexCount\r\n    });\r\n  }\r\n\r\n  draw(): void {\r\n    const {model} = this.state;\r\n    const {\r\n      aggregationMode,\r\n      colorDomain,\r\n      intensity,\r\n      threshold,\r\n      colorTexture,\r\n      maxTexture,\r\n      weightsTexture\r\n    } = this.props;\r\n    const triangleProps: TriangleProps = {\r\n      aggregationMode,\r\n      colorDomain,\r\n      intensity,\r\n      threshold,\r\n      colorTexture,\r\n      maxTexture,\r\n      weightsTexture\r\n    };\r\n    model.shaderInputs.setProps({triangle: triangleProps});\r\n    model.draw(this.context.renderPass);\r\n  }\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport function filterProps(props, filterKeys) {\r\n  const filteredProps = {};\r\n  for (const key in props) {\r\n    if (!filterKeys.includes(key)) {\r\n      filteredProps[key] = props[key];\r\n    }\r\n  }\r\n  return filteredProps;\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {\r\n  CompositeLayer,\r\n  AttributeManager,\r\n  LayerDataSource,\r\n  _compareProps as compareProps,\r\n  UpdateParameters,\r\n  CompositeLayerProps,\r\n  Attribute\r\n} from '@deck.gl/core';\r\nimport {filterProps} from '../common/utils/prop-utils';\r\n\r\nexport type AggregationLayerProps<DataT> = CompositeLayerProps & {\r\n  data: LayerDataSource<DataT>;\r\n};\r\n\r\n/** Legacy AggregationLayer, to be removed in v9.1 */\r\nexport default abstract class AggregationLayer<\r\n  DataT,\r\n  ExtraPropsT extends {} = {}\r\n> extends CompositeLayer<Required<AggregationLayer<DataT>> & ExtraPropsT> {\r\n  static layerName = 'AggregationLayer';\r\n\r\n  state!: {\r\n    ignoreProps?: Record<string, any>;\r\n    dimensions?: any;\r\n    changedAttributes?: Record<string, any>;\r\n  };\r\n\r\n  initializeAggregationLayer(dimensions: any) {\r\n    super.initializeState(this.context);\r\n\r\n    this.setState({\r\n      // Layer props , when changed doesn't require updating aggregation\r\n      ignoreProps: filterProps((this.constructor as any)._propTypes, dimensions.data.props),\r\n      dimensions\r\n    });\r\n  }\r\n\r\n  updateState(opts: UpdateParameters<this>) {\r\n    super.updateState(opts);\r\n    const {changeFlags} = opts;\r\n    if (changeFlags.extensionsChanged) {\r\n      const shaders = this.getShaders({});\r\n      if (shaders && shaders.defines) {\r\n        shaders.defines.NON_INSTANCED_MODEL = 1;\r\n      }\r\n      this.updateShaders(shaders);\r\n    }\r\n\r\n    // Explictly call to update attributes as 'CompositeLayer' doesn't call this\r\n    this._updateAttributes();\r\n  }\r\n\r\n  updateAttributes(changedAttributes) {\r\n    // Super classes, can refer to state.changedAttributes to determine what\r\n    // attributes changed\r\n    this.setState({changedAttributes});\r\n  }\r\n\r\n  getAttributes(): {[id: string]: Attribute} {\r\n    return this.getAttributeManager()!.getAttributes();\r\n  }\r\n\r\n  getModuleSettings() {\r\n    // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle\r\n    // For aggregation layers this is called during updateState to update aggregation data\r\n    // NOTE: it is similar to LayerPass._getShaderModuleProps() but doesn't inlcude `effects` it is not needed for aggregation\r\n    const {viewport, mousePosition, device} = this.context;\r\n    const moduleSettings = Object.assign(Object.create(this.props), {\r\n      viewport,\r\n      mousePosition,\r\n      picking: {\r\n        isActive: 0\r\n      },\r\n      // @ts-expect-error TODO - assuming WebGL context\r\n      devicePixelRatio: device.canvasContext.cssToDeviceRatio()\r\n    });\r\n    return moduleSettings;\r\n  }\r\n\r\n  updateShaders(shaders) {\r\n    // Default implemention is empty, subclasses can update their Model objects if needed\r\n  }\r\n\r\n  /**\r\n   * Checks if aggregation is dirty\r\n   * @param {Object} updateOpts - object {props, oldProps, changeFlags}\r\n   * @param {Object} params - object {dimension, compareAll}\r\n   * @param {Object} params.dimension - {props, accessors} array of props and/or accessors\r\n   * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision\r\n   * @returns {Boolean} - returns true if dimensions' prop or accessor is changed\r\n   **/\r\n  isAggregationDirty(\r\n    updateOpts,\r\n    params: {compareAll?: boolean; dimension?: any} = {}\r\n  ): string | boolean {\r\n    const {props, oldProps, changeFlags} = updateOpts;\r\n    const {compareAll = false, dimension} = params;\r\n    const {ignoreProps} = this.state;\r\n    const {props: dataProps, accessors = []} = dimension;\r\n    const {updateTriggersChanged} = changeFlags;\r\n    if (changeFlags.dataChanged) {\r\n      return true;\r\n    }\r\n    if (updateTriggersChanged) {\r\n      if (updateTriggersChanged.all) {\r\n        return true;\r\n      }\r\n      for (const accessor of accessors) {\r\n        if (updateTriggersChanged[accessor]) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    if (compareAll) {\r\n      if (changeFlags.extensionsChanged) {\r\n        return true;\r\n      }\r\n      // Compare non layer props too (like extension props)\r\n      // ignoreprops refers to all Layer props other than aggregation props that need to be comapred\r\n      return compareProps({\r\n        oldProps,\r\n        newProps: props,\r\n        ignoreProps,\r\n        propTypes: (this.constructor as any)._propTypes\r\n      });\r\n    }\r\n    // Compare props of the dimension\r\n    for (const name of dataProps) {\r\n      if (props[name] !== oldProps[name]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Checks if an attribute is changed\r\n   * @param {String} name - name of the attribute\r\n   * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,\r\n   *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise\r\n   **/\r\n  isAttributeChanged(name?: string) {\r\n    const {changedAttributes} = this.state;\r\n    if (!name) {\r\n      // if name not specified return true if any attribute is changed\r\n      return !isObjectEmpty(changedAttributes);\r\n    }\r\n    return changedAttributes && changedAttributes[name] !== undefined;\r\n  }\r\n\r\n  // Private\r\n\r\n  // override Composite layer private method to create AttributeManager instance\r\n  _getAttributeManager() {\r\n    return new AttributeManager(this.context.device, {\r\n      id: this.props.id,\r\n      stats: this.context.stats\r\n    });\r\n  }\r\n}\r\n\r\n// Helper methods\r\n\r\n// Returns true if given object is empty, false otherwise.\r\nfunction isObjectEmpty(obj) {\r\n  let isEmpty = true;\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  for (const key in obj) {\r\n    isEmpty = false;\r\n    break;\r\n  }\r\n  return isEmpty;\r\n}\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport default `\\\r\n#version 300 es\r\nin vec3 positions;\r\nin vec3 positions64Low;\r\nin float weights;\r\nout vec4 weightsTexture;\r\n\r\nvoid main()\r\n{\r\n  weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);\r\n\r\n  float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);\r\n  gl_PointSize = radiusTexels * 2.;\r\n\r\n  vec3 commonPosition = project_position(positions, positions64Low);\r\n\r\n  // // map xy from commonBounds to [-1, 1]\r\n  gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;\r\n  gl_Position.xy = (gl_Position.xy * 2.) - (1.);\r\n  gl_Position.w = 1.0;\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport default `\\\r\n#version 300 es\r\nin vec4 weightsTexture;\r\nout vec4 fragColor;\r\n// Epanechnikov function, keeping for reference\r\n// float epanechnikovKDE(float u) {\r\n//   return 0.75 * (1.0 - u * u);\r\n// }\r\nfloat gaussianKDE(float u){\r\n  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\r\n}\r\nvoid main()\r\n{\r\n  float dist = length(gl_PointCoord - vec2(0.5, 0.5));\r\n  if (dist > 0.5) {\r\n    discard;\r\n  }\r\n  fragColor = weightsTexture * gaussianKDE(2. * dist);\r\n  DECKGL_FILTER_COLOR(fragColor, geometry);\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport default `\\\r\n#version 300 es\r\nuniform sampler2D inTexture;\r\nout vec4 outTexture;\r\n\r\nvoid main()\r\n{\r\n  // Sample every pixel in texture\r\n  int yIndex = gl_VertexID / int(maxWeight.textureSize);\r\n  int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));\r\n  vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;\r\n  outTexture = texture(inTexture, uv);\r\n\r\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\r\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\r\n  gl_PointSize = 1.0;\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nexport default `\\\r\n#version 300 es\r\nin vec4 outTexture;\r\nout vec4 fragColor;\r\nvoid main() {\r\n  fragColor = outTexture;\r\n  fragColor.g = outTexture.r / max(1.0, outTexture.a);\r\n}\r\n`;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\nimport {Texture} from '@luma.gl/core';\r\nimport type {ShaderModule} from '@luma.gl/shadertools';\r\n\r\nconst uniformBlock = `\\\r\nuniform weightUniforms {\r\n  vec4 commonBounds;\r\n  float radiusPixels;\r\n  float textureWidth;\r\n  float weightsScale;\r\n} weight;\r\n`;\r\nexport type WeightProps = {\r\n  commonBounds: [number, number, number, number];\r\n  radiusPixels: number;\r\n  textureWidth: number;\r\n  weightsScale: number;\r\n  weightsTexture: Texture;\r\n};\r\n\r\nexport const weightUniforms = {\r\n  name: 'weight',\r\n  vs: uniformBlock,\r\n  uniformTypes: {\r\n    commonBounds: 'vec4<f32>',\r\n    radiusPixels: 'f32',\r\n    textureWidth: 'f32',\r\n    weightsScale: 'f32'\r\n  }\r\n} as const satisfies ShaderModule<WeightProps>;\r\n\r\nexport type MaxWeightProps = {\r\n  inTexture: Texture;\r\n  textureSize: number;\r\n};\r\n\r\nexport const maxWeightUniforms = {\r\n  name: 'maxWeight',\r\n  vs: `\\\r\nuniform maxWeightUniforms {\r\n  float textureSize;\r\n} maxWeight;\r\n`,\r\n  uniformTypes: {\r\n    textureSize: 'f32'\r\n  }\r\n} as const satisfies ShaderModule<MaxWeightProps>;\r\n", "// deck.gl\r\n// SPDX-License-Identifier: MIT\r\n// Copyright (c) vis.gl contributors\r\n\r\n/* global setTimeout clearTimeout */\r\nimport {\r\n  getBounds,\r\n  boundsContain,\r\n  packVertices,\r\n  scaleToAspectRatio,\r\n  getTextureCoordinates\r\n} from './heatmap-layer-utils';\r\nimport {Buffer, DeviceFeature, Texture, TextureProps, TextureFormat} from '@luma.gl/core';\r\nimport {TextureTransform, TextureTransformProps} from '@luma.gl/engine';\r\nimport {\r\n  Accessor,\r\n  AccessorFunction,\r\n  AttributeManager,\r\n  ChangeFlags,\r\n  Color,\r\n  COORDINATE_SYSTEM,\r\n  Layer,\r\n  LayerContext,\r\n  LayersList,\r\n  log,\r\n  Position,\r\n  UpdateParameters,\r\n  DefaultProps,\r\n  project32\r\n} from '@deck.gl/core';\r\nimport TriangleLayer from './triangle-layer';\r\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\r\nimport {defaultColorRange, colorRangeToFlatArray} from '../common/utils/color-utils';\r\nimport weightsVs from './weights-vs.glsl';\r\nimport weightsFs from './weights-fs.glsl';\r\nimport maxVs from './max-vs.glsl';\r\nimport maxFs from './max-fs.glsl';\r\nimport {\r\n  MaxWeightProps,\r\n  maxWeightUniforms,\r\n  WeightProps,\r\n  weightUniforms\r\n} from './heatmap-layer-uniforms';\r\n\r\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\r\nconst TEXTURE_PROPS: TextureProps = {\r\n  format: 'rgba8unorm',\r\n  mipmaps: false,\r\n  sampler: {\r\n    minFilter: 'linear',\r\n    magFilter: 'linear',\r\n    addressModeU: 'clamp-to-edge',\r\n    addressModeV: 'clamp-to-edge'\r\n  }\r\n};\r\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\r\nconst AGGREGATION_MODE = {\r\n  SUM: 0,\r\n  MEAN: 1\r\n};\r\n\r\nconst defaultProps: DefaultProps<HeatmapLayerProps> = {\r\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\r\n  getWeight: {type: 'accessor', value: 1},\r\n  intensity: {type: 'number', min: 0, value: 1},\r\n  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},\r\n  colorRange: defaultColorRange,\r\n  threshold: {type: 'number', min: 0, max: 1, value: 0.05},\r\n  colorDomain: {type: 'array', value: null, optional: true},\r\n  // 'SUM' or 'MEAN'\r\n  aggregation: 'SUM',\r\n  weightsTextureSize: {type: 'number', min: 128, max: 2048, value: 2048},\r\n  debounceTimeout: {type: 'number', min: 0, max: 1000, value: 500}\r\n};\r\n\r\nconst FLOAT_TARGET_FEATURES: DeviceFeature[] = [\r\n  'float32-renderable-webgl', // ability to render to float texture\r\n  'texture-blend-float-webgl' // ability to blend when rendering to float texture\r\n];\r\n\r\nconst DIMENSIONS = {\r\n  data: {\r\n    props: ['radiusPixels']\r\n  }\r\n};\r\n\r\nexport type HeatmapLayerProps<DataT = unknown> = _HeatmapLayerProps<DataT> &\r\n  AggregationLayerProps<DataT>;\r\n\r\ntype _HeatmapLayerProps<DataT> = {\r\n  /**\r\n   * Radius of the circle in pixels, to which the weight of an object is distributed.\r\n   *\r\n   * @default 30\r\n   */\r\n  radiusPixels?: number;\r\n\r\n  /**\r\n   * Specified as an array of colors [color1, color2, ...].\r\n   *\r\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\r\n   */\r\n  colorRange?: Color[];\r\n\r\n  /**\r\n   * Value that is multiplied with the total weight at a pixel to obtain the final weight.\r\n   *\r\n   * @default 1\r\n   */\r\n  intensity?: number;\r\n\r\n  /**\r\n   * Ratio of the fading weight to the max weight, between `0` and `1`.\r\n   *\r\n   * For example, `0.1` affects all pixels with weight under 10% of the max.\r\n   *\r\n   * Ignored when `colorDomain` is specified.\r\n   * @default 0.05\r\n   */\r\n  threshold?: number;\r\n\r\n  /**\r\n   * Controls how weight values are mapped to the `colorRange`, as an array of two numbers [`minValue`, `maxValue`].\r\n   *\r\n   * @default null\r\n   */\r\n  colorDomain?: [number, number] | null;\r\n\r\n  /**\r\n   * Defines the type of aggregation operation\r\n   *\r\n   * V valid values are 'SUM', 'MEAN'.\r\n   *\r\n   * @default 'SUM'\r\n   */\r\n  aggregation?: 'SUM' | 'MEAN';\r\n\r\n  /**\r\n   * Specifies the size of weight texture.\r\n   * @default 2048\r\n   */\r\n  weightsTextureSize?: number;\r\n\r\n  /**\r\n   * Interval in milliseconds during which changes to the viewport don't trigger aggregation.\r\n   *\r\n   * @default 500\r\n   */\r\n  debounceTimeout?: number;\r\n\r\n  /**\r\n   * Method called to retrieve the position of each object.\r\n   *\r\n   * @default d => d.position\r\n   */\r\n  getPosition?: AccessorFunction<DataT, Position>;\r\n\r\n  /**\r\n   * The weight of each object.\r\n   *\r\n   * @default 1\r\n   */\r\n  getWeight?: Accessor<DataT, number>;\r\n};\r\n\r\n/** Visualizes the spatial distribution of data. */\r\nexport default class HeatmapLayer<\r\n  DataT = any,\r\n  ExtraPropsT extends {} = {}\r\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HeatmapLayerProps<DataT>>> {\r\n  static layerName = 'HeatmapLayer';\r\n  static defaultProps = defaultProps;\r\n\r\n  state!: AggregationLayer<DataT>['state'] & {\r\n    colorDomain?: number[];\r\n    isWeightMapDirty?: boolean;\r\n    weightsTexture?: Texture;\r\n    maxWeightsTexture?: Texture;\r\n    colorTexture?: Texture;\r\n    zoom?: number;\r\n    worldBounds?: number[];\r\n    normalizedCommonBounds?: number[];\r\n    updateTimer?: any;\r\n    triPositionBuffer?: Buffer;\r\n    triTexCoordBuffer?: Buffer;\r\n    weightsTransform?: TextureTransform;\r\n    maxWeightTransform?: TextureTransform;\r\n    textureSize: number;\r\n    format: TextureFormat;\r\n    weightsScale: number;\r\n    visibleWorldBounds: number[];\r\n    viewportCorners: number[][];\r\n  };\r\n\r\n  getShaders(shaders: any) {\r\n    let modules = [project32];\r\n    if (shaders.modules) {\r\n      modules = [...modules, ...shaders.modules];\r\n    }\r\n\r\n    return super.getShaders({...shaders, modules});\r\n  }\r\n\r\n  initializeState() {\r\n    super.initializeAggregationLayer(DIMENSIONS);\r\n    this.setState({colorDomain: DEFAULT_COLOR_DOMAIN});\r\n    this._setupTextureParams();\r\n    this._setupAttributes();\r\n    this._setupResources();\r\n  }\r\n\r\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\r\n    // Need to be updated when viewport changes\r\n    return changeFlags.somethingChanged;\r\n  }\r\n\r\n  /* eslint-disable max-statements,complexity */\r\n  updateState(opts: UpdateParameters<this>) {\r\n    super.updateState(opts);\r\n    this._updateHeatmapState(opts);\r\n  }\r\n\r\n  _updateHeatmapState(opts: UpdateParameters<this>) {\r\n    const {props, oldProps} = opts;\r\n    const changeFlags = this._getChangeFlags(opts);\r\n\r\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\r\n      // if data is changed, do not debounce and immediately update the weight map\r\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\r\n      this._updateTextureRenderingBounds();\r\n    }\r\n\r\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\r\n      // Update weight map immediately\r\n      clearTimeout(this.state.updateTimer);\r\n      this.setState({isWeightMapDirty: true});\r\n    } else if (changeFlags.viewportZoomChanged) {\r\n      // Update weight map when zoom stops\r\n      this._debouncedUpdateWeightmap();\r\n    }\r\n\r\n    if (props.colorRange !== oldProps.colorRange) {\r\n      this._updateColorTexture(opts);\r\n    }\r\n\r\n    if (this.state.isWeightMapDirty) {\r\n      this._updateWeightmap();\r\n    }\r\n\r\n    this.setState({zoom: opts.context.viewport.zoom});\r\n  }\r\n\r\n  renderLayers(): LayersList | Layer {\r\n    const {\r\n      weightsTexture,\r\n      triPositionBuffer,\r\n      triTexCoordBuffer,\r\n      maxWeightsTexture,\r\n      colorTexture,\r\n      colorDomain\r\n    } = this.state;\r\n    const {updateTriggers, intensity, threshold, aggregation} = this.props;\r\n\r\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\r\n\r\n    return new TriangleLayerClass(\r\n      this.getSubLayerProps({\r\n        id: 'triangle-layer',\r\n        updateTriggers\r\n      }),\r\n      {\r\n        // position buffer is filled with world coordinates generated from viewport.unproject\r\n        // i.e. LNGLAT if geospatial, CARTESIAN otherwise\r\n        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\r\n        data: {\r\n          attributes: {\r\n            positions: triPositionBuffer,\r\n            texCoords: triTexCoordBuffer\r\n          }\r\n        },\r\n        vertexCount: 4,\r\n        maxTexture: maxWeightsTexture,\r\n        colorTexture,\r\n        aggregationMode: AGGREGATION_MODE[aggregation] || 0,\r\n        weightsTexture,\r\n        intensity,\r\n        threshold,\r\n        colorDomain\r\n      }\r\n    );\r\n  }\r\n\r\n  finalizeState(context: LayerContext) {\r\n    super.finalizeState(context);\r\n    const {\r\n      weightsTransform,\r\n      weightsTexture,\r\n      maxWeightTransform,\r\n      maxWeightsTexture,\r\n      triPositionBuffer,\r\n      triTexCoordBuffer,\r\n      colorTexture,\r\n      updateTimer\r\n    } = this.state;\r\n    weightsTransform?.destroy();\r\n    weightsTexture?.destroy();\r\n    maxWeightTransform?.destroy();\r\n    maxWeightsTexture?.destroy();\r\n    triPositionBuffer?.destroy();\r\n    triTexCoordBuffer?.destroy();\r\n    colorTexture?.destroy();\r\n    if (updateTimer) {\r\n      clearTimeout(updateTimer);\r\n    }\r\n  }\r\n\r\n  // PRIVATE\r\n\r\n  // override Composite layer private method to create AttributeManager instance\r\n  _getAttributeManager() {\r\n    return new AttributeManager(this.context.device, {\r\n      id: this.props.id,\r\n      stats: this.context.stats\r\n    });\r\n  }\r\n\r\n  _getChangeFlags(opts: UpdateParameters<this>) {\r\n    const changeFlags: Partial<ChangeFlags> & {\r\n      boundsChanged?: boolean;\r\n      viewportZoomChanged?: boolean;\r\n    } = {};\r\n    const {dimensions} = this.state;\r\n    changeFlags.dataChanged =\r\n      (this.isAttributeChanged() && 'attribute changed') || // if any attribute is changed\r\n      (this.isAggregationDirty(opts, {\r\n        compareAll: true,\r\n        dimension: dimensions.data\r\n      }) &&\r\n        'aggregation is dirty');\r\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\r\n\r\n    const {zoom} = this.state;\r\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\r\n      changeFlags.viewportZoomChanged = true;\r\n    }\r\n\r\n    return changeFlags;\r\n  }\r\n\r\n  _createTextures() {\r\n    const {textureSize, format} = this.state;\r\n\r\n    this.setState({\r\n      weightsTexture: this.context.device.createTexture({\r\n        ...TEXTURE_PROPS,\r\n        width: textureSize,\r\n        height: textureSize,\r\n        format\r\n      }),\r\n      maxWeightsTexture: this.context.device.createTexture({\r\n        ...TEXTURE_PROPS,\r\n        width: 1,\r\n        height: 1,\r\n        format\r\n      })\r\n    });\r\n  }\r\n\r\n  _setupAttributes() {\r\n    const attributeManager = this.getAttributeManager()!;\r\n    attributeManager.add({\r\n      positions: {size: 3, type: 'float64', accessor: 'getPosition'},\r\n      weights: {size: 1, accessor: 'getWeight'}\r\n    });\r\n    this.setState({positionAttributeName: 'positions'});\r\n  }\r\n\r\n  _setupTextureParams() {\r\n    const {device} = this.context;\r\n    const {weightsTextureSize} = this.props;\r\n\r\n    const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);\r\n    const floatTargetSupport = FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\r\n    const format: TextureFormat = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';\r\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\r\n    this.setState({textureSize, format, weightsScale});\r\n    if (!floatTargetSupport) {\r\n      log.warn(\r\n        `HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`\r\n      )();\r\n    }\r\n  }\r\n\r\n  _createWeightsTransform(shaders: {vs: string; fs?: string; modules: any[]}) {\r\n    let {weightsTransform} = this.state;\r\n    const {weightsTexture} = this.state;\r\n    const attributeManager = this.getAttributeManager()!;\r\n\r\n    weightsTransform?.destroy();\r\n    weightsTransform = new TextureTransform(this.context.device, {\r\n      id: `${this.id}-weights-transform`,\r\n      bufferLayout: attributeManager.getBufferLayouts(),\r\n      vertexCount: 1,\r\n      targetTexture: weightsTexture!,\r\n      parameters: {\r\n        depthWriteEnabled: false,\r\n        blendColorOperation: 'add',\r\n        blendColorSrcFactor: 'one',\r\n        blendColorDstFactor: 'one',\r\n        blendAlphaSrcFactor: 'one',\r\n        blendAlphaDstFactor: 'one'\r\n      },\r\n      topology: 'point-list',\r\n      ...shaders,\r\n      modules: [...shaders.modules, weightUniforms]\r\n    } as TextureTransformProps);\r\n\r\n    this.setState({weightsTransform});\r\n  }\r\n\r\n  _setupResources() {\r\n    this._createTextures();\r\n    const {device} = this.context;\r\n    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;\r\n\r\n    const weightsTransformShaders = this.getShaders({\r\n      vs: weightsVs,\r\n      fs: weightsFs\r\n    });\r\n    this._createWeightsTransform(weightsTransformShaders);\r\n\r\n    const maxWeightsTransformShaders = this.getShaders({\r\n      vs: maxVs,\r\n      fs: maxFs,\r\n      modules: [maxWeightUniforms]\r\n    });\r\n    const maxWeightTransform = new TextureTransform(device, {\r\n      id: `${this.id}-max-weights-transform`,\r\n      targetTexture: maxWeightsTexture!,\r\n      ...maxWeightsTransformShaders,\r\n      vertexCount: textureSize * textureSize,\r\n      topology: 'point-list',\r\n      parameters: {\r\n        depthWriteEnabled: false,\r\n        blendColorOperation: 'max',\r\n        blendAlphaOperation: 'max',\r\n        blendColorSrcFactor: 'one',\r\n        blendColorDstFactor: 'one',\r\n        blendAlphaSrcFactor: 'one',\r\n        blendAlphaDstFactor: 'one'\r\n      }\r\n    });\r\n\r\n    const maxWeightProps: MaxWeightProps = {inTexture: weightsTexture!, textureSize};\r\n    maxWeightTransform.model.shaderInputs.setProps({\r\n      maxWeight: maxWeightProps\r\n    });\r\n\r\n    this.setState({\r\n      weightsTexture,\r\n      maxWeightsTexture,\r\n      maxWeightTransform,\r\n      zoom: null,\r\n      triPositionBuffer: device.createBuffer({byteLength: 48}),\r\n      triTexCoordBuffer: device.createBuffer({byteLength: 48})\r\n    });\r\n  }\r\n\r\n  // overwrite super class method to update transform model\r\n  updateShaders(shaderOptions) {\r\n    // shader params (modules, injects) changed, update model object\r\n    this._createWeightsTransform({\r\n      vs: weightsVs,\r\n      fs: weightsFs,\r\n      ...shaderOptions\r\n    });\r\n  }\r\n\r\n  _updateMaxWeightValue() {\r\n    const {maxWeightTransform} = this.state;\r\n\r\n    maxWeightTransform!.run({\r\n      parameters: {viewport: [0, 0, 1, 1]},\r\n      clearColor: [0, 0, 0, 0]\r\n    });\r\n  }\r\n\r\n  // Computes world bounds area that needs to be processed for generate heatmap\r\n  _updateBounds(forceUpdate: any = false): boolean {\r\n    const {viewport} = this.context;\r\n\r\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\r\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\r\n    const viewportCorners = [\r\n      viewport.unproject([0, 0]),\r\n      viewport.unproject([viewport.width, 0]),\r\n      viewport.unproject([0, viewport.height]),\r\n      viewport.unproject([viewport.width, viewport.height])\r\n    ].map(p => p.map(Math.fround));\r\n\r\n    // #1: get world bounds for current viewport extends\r\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\r\n\r\n    const newState: Partial<HeatmapLayer['state']> = {visibleWorldBounds, viewportCorners};\r\n    let boundsChanged = false;\r\n\r\n    if (\r\n      forceUpdate ||\r\n      !this.state.worldBounds ||\r\n      !boundsContain(this.state.worldBounds, visibleWorldBounds)\r\n    ) {\r\n      // #2 : convert world bounds to common (Flat) bounds\r\n      // #3 : extend common bounds to match aspect ratio with viewport\r\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\r\n\r\n      // #4 :convert aligned common bounds to world bounds\r\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\r\n\r\n      // Clip webmercator projection limits\r\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\r\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\r\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\r\n        worldBounds[0] = Math.max(worldBounds[0], -360);\r\n        worldBounds[2] = Math.min(worldBounds[2], 360);\r\n      }\r\n\r\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\r\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\r\n\r\n      newState.worldBounds = worldBounds;\r\n      newState.normalizedCommonBounds = normalizedCommonBounds;\r\n\r\n      boundsChanged = true;\r\n    }\r\n    this.setState(newState);\r\n    return boundsChanged;\r\n  }\r\n\r\n  _updateTextureRenderingBounds() {\r\n    // Just render visible portion of the texture\r\n    const {triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners} =\r\n      this.state;\r\n\r\n    const {viewport} = this.context;\r\n\r\n    triPositionBuffer!.write(packVertices(viewportCorners, 3));\r\n\r\n    const textureBounds = viewportCorners.map(p =>\r\n      getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds!)\r\n    );\r\n    triTexCoordBuffer!.write(packVertices(textureBounds, 2));\r\n  }\r\n\r\n  _updateColorTexture(opts) {\r\n    const {colorRange} = opts.props;\r\n    let {colorTexture} = this.state;\r\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array as any);\r\n\r\n    if (colorTexture && colorTexture?.width === colorRange.length) {\r\n      // TODO(v9): Unclear whether `setSubImageData` is a public API, or what to use if not.\r\n      (colorTexture as any).setTexture2DData({data: colors});\r\n    } else {\r\n      colorTexture?.destroy();\r\n      // @ts-expect-error TODO(ib) - texture API change\r\n      colorTexture = this.context.device.createTexture({\r\n        ...TEXTURE_PROPS,\r\n        data: colors,\r\n        width: colorRange.length,\r\n        height: 1\r\n      });\r\n    }\r\n    this.setState({colorTexture});\r\n  }\r\n\r\n  _updateWeightmap() {\r\n    const {radiusPixels, colorDomain, aggregation} = this.props;\r\n    const {worldBounds, textureSize, weightsScale, weightsTexture} = this.state;\r\n    const weightsTransform = this.state.weightsTransform!;\r\n    this.state.isWeightMapDirty = false;\r\n\r\n    // convert world bounds to common using Layer's coordiante system and origin\r\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\r\n      useLayerCoordinateSystem: true\r\n    });\r\n\r\n    if (colorDomain && aggregation === 'SUM') {\r\n      // scale color domain to weight per pixel\r\n      const {viewport} = this.context;\r\n      const metersPerPixel =\r\n        (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\r\n        textureSize;\r\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\r\n    } else {\r\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\r\n    }\r\n\r\n    const attributeManager = this.getAttributeManager()!;\r\n    const attributes = attributeManager.getAttributes();\r\n    const moduleSettings = this.getModuleSettings();\r\n    this._setModelAttributes(weightsTransform.model, attributes);\r\n    weightsTransform.model.setVertexCount(this.getNumInstances());\r\n\r\n    const weightProps: WeightProps = {\r\n      radiusPixels,\r\n      commonBounds,\r\n      textureWidth: textureSize,\r\n      weightsScale,\r\n      weightsTexture: weightsTexture!\r\n    };\r\n    const {viewport, devicePixelRatio, coordinateSystem, coordinateOrigin} = moduleSettings;\r\n    const {modelMatrix} = this.props;\r\n    weightsTransform.model.shaderInputs.setProps({\r\n      project: {viewport, devicePixelRatio, modelMatrix, coordinateSystem, coordinateOrigin},\r\n      weight: weightProps\r\n    });\r\n    weightsTransform.run({\r\n      parameters: {viewport: [0, 0, textureSize, textureSize]},\r\n      clearColor: [0, 0, 0, 0]\r\n    });\r\n\r\n    this._updateMaxWeightValue();\r\n  }\r\n\r\n  _debouncedUpdateWeightmap(fromTimer = false) {\r\n    let {updateTimer} = this.state;\r\n    const {debounceTimeout} = this.props;\r\n\r\n    if (fromTimer) {\r\n      updateTimer = null;\r\n      // update\r\n      this._updateBounds(true);\r\n      this._updateTextureRenderingBounds();\r\n      this.setState({isWeightMapDirty: true});\r\n    } else {\r\n      this.setState({isWeightMapDirty: false});\r\n      clearTimeout(updateTimer);\r\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\r\n    }\r\n\r\n    this.setState({updateTimer});\r\n  }\r\n\r\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\r\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\r\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\r\n  _worldToCommonBounds(\r\n    worldBounds,\r\n    opts: {useLayerCoordinateSystem?: boolean} = {}\r\n  ): [number, number, number, number] {\r\n    const {useLayerCoordinateSystem = false} = opts;\r\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\r\n    const {viewport} = this.context;\r\n    const {textureSize} = this.state;\r\n    const {coordinateSystem} = this.props;\r\n\r\n    const offsetMode =\r\n      useLayerCoordinateSystem &&\r\n      (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\r\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\r\n    const offsetOriginCommon = offsetMode\r\n      ? viewport.projectPosition(this.props.coordinateOrigin)\r\n      : [0, 0];\r\n    const size = (textureSize * RESOLUTION) / viewport.scale;\r\n\r\n    let bottomLeftCommon;\r\n    let topRightCommon;\r\n\r\n    // Y-axis is flipped between World and Common bounds\r\n    if (useLayerCoordinateSystem && !offsetMode) {\r\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\r\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\r\n    } else {\r\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\r\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\r\n    }\r\n    // Ignore z component\r\n    return scaleToAspectRatio(\r\n      [\r\n        bottomLeftCommon[0] - offsetOriginCommon[0],\r\n        bottomLeftCommon[1] - offsetOriginCommon[1],\r\n        topRightCommon[0] - offsetOriginCommon[0],\r\n        topRightCommon[1] - offsetOriginCommon[1]\r\n      ],\r\n      size,\r\n      size\r\n    );\r\n  }\r\n\r\n  // input commonBounds: [xMin, yMin, xMax, yMax]\r\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\r\n  _commonToWorldBounds(commonBounds) {\r\n    const [xMin, yMin, xMax, yMax] = commonBounds;\r\n    const {viewport} = this.context;\r\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\r\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\r\n\r\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["min", "max", "uniformBlock", "MAX_FLOAT32", "count", "uniformBlock", "uniformBlock", "uniformBlock", "uniformBlock", "binOptionsUniforms", "defaultProps", "binOptionsUniforms", "threshold", "threshold", "count", "uniformBlock", "binOptionsUniforms", "defaultProps", "binOptionsUniforms", "uniformBlock", "uniformBlock", "binOptionsUniforms", "noop", "defaultProps", "GridLayer", "binOptionsUniforms", "uniformBlock", "threshold", "AggregationLayer", "uniformBlock", "defaultProps", "aggregation_layer_default", "threshold", "viewport"]
}
